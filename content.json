{"meta":{"title":"SioCheung","subtitle":"君子求诸己","description":"打怪升级，游戏人生","author":"SioCheung","url":"https://joacycode.github.io"},"pages":[{"title":"标签","date":"2018-01-22T17:20:01.000Z","updated":"2021-09-22T07:45:32.217Z","comments":true,"path":"tags/index.html","permalink":"https://joacycode.github.io/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-01-22T17:20:15.000Z","updated":"2021-09-22T07:45:32.217Z","comments":true,"path":"categories/index.html","permalink":"https://joacycode.github.io/categories/index.html","excerpt":"","text":""},{"title":"Search","date":"2018-07-13T14:46:27.000Z","updated":"2021-09-22T07:45:32.194Z","comments":true,"path":"Search/index.html","permalink":"https://joacycode.github.io/Search/index.html","excerpt":"","text":""}],"posts":[{"title":"DSL介绍和使用","slug":"2021-record-dsl","date":"2021-01-18T15:37:16.000Z","updated":"2021-09-26T02:00:01.912Z","comments":true,"path":"posts/a0e43f83/","link":"","permalink":"https://joacycode.github.io/posts/a0e43f83/","excerpt":"","text":"原创内容，欢迎交流转载请注明出处","categories":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}],"tags":[{"name":"tag","slug":"tag","permalink":"https://joacycode.github.io/tags/tag/"}],"keywords":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}]},{"title":"你不知道的AST","slug":"2021-es-ast","date":"2020-06-02T20:30:01.000Z","updated":"2021-09-26T02:00:01.913Z","comments":true,"path":"posts/15ddfa03/","link":"","permalink":"https://joacycode.github.io/posts/15ddfa03/","excerpt":"","text":"源代码语法结构的一种抽象表示，树状结构每个节点都表示源代码中的一种结构，我们熟知的babel、webpack、vue-cli 得都是依赖 AST 进行开发的，强大到称为前端顶级领域的基座知识点。 ast生成方式，从词法分析到语法分析，词法分析（扫描）生成 token，语法分析生成ast树。 词法的token是最小分割单元，虽然是逐字母字符读取，但是会与内建的关键词与符号比较，关键词会作为一个整体作为token，如function、var、if等等，最终生成token列表。 语法分析（parse）,将词法分析的token转成有特定语法的语法树结构。parse的工具有很多babel、esprima以及基于两者封装的recast 1234import recast from 'recast'var sourcecode = function add (x,y)&#123;truereturn x+y&#125; recastrecast.parse将代码全部拆解成ast结构对象 1var astTree = recast.parse(sourcecode) recast.print[prettyPrint]输出ast对象，美化输出prettyPrint，输出配置文档 12console.log(recast.print(astTree))//console.log(recast.prettyPrint(astTree,&#123; tabWidth: 2 &#125;)) 输出源码 12console.log(recast.print(astTree).code)//console.log(recast.prettyPrint(astTree, &#123; tabWidth: 2 &#125;).code) recast.run命令行文件读取 123recast.run((ast, printSource) =&gt; &#123; // some code here&#125;) 通过 fs.readFile 进行文件读取，然后将获取到的 code 进行 parse 操作 源码有对run的实现，其中printSource方法本质就是process.stdout.write。recast没有详细的文档但是入口文件就已经告诉你所有的api以及对应的使用方式了（依赖包如ast-types有详细的使用文档） recast.types.builderparse可以把现有的代码拆解一块块ast对象，那么builder提供就是重新构建这些ast对象的工具。AST对象文档中定义的builders对象，具体的builder类型方法也可以使用ast-types的builders.ts。 recast.visit遍历ast对象 拆解和拼接的工具都有了，还需要分类遍历巨量的ast的对象，从中取出需要的模块的工具–visit，一个根据ast对象类型进行分类遍历的方法。 parse拆解出全部堆在一起，visit按照类型取出特定类型对象。只要在 AST对象文档中定义的builders对象（也可以使用ast-types的builders.ts），在前面加visit，即可遍历，每个遍历函数后必须加上return false或者 this.traverse(path)，否则报错。 Error: Must either call this.traverse or return false in visitFunctionDeclaration 123456789101112const recast = require('recast')recast.run(function(ast, printSource) &#123; recast.visit(ast, &#123; visitExpressionStatement: function(&#123;node&#125;) &#123; // 解构node的属性方法是哪些取决于当前节点的ast对象类型 console.log(node) //输出ast对象 printSource(node) // ast对象对应的源码 return false // required &#125; &#125;);&#125;); recast.types.nameTypes两个常见的api：assert() check()，具体用法 1234// assert 类型不匹配报错退出recast.types.namedTypes.assert()// check 返回 booleanrecast.types.namedTypes.check() 12345 // 用法 assert() check()const recast = require(\"recast\");const TNT = recast.types.namedTypesTNT[ASTObject].check(CamparedASTObject) // 对比ast对象 返回booleanTNT[ASTObject].assert(CamparedASTObject) // ast对象不一致报错退出 思考题将下面的函数 123function add (a, b) &#123; return a + b&#125; 转换成箭头函数导出 123exports.add = (a, b) =&gt; &#123; return a + b&#125; 比较常见的低效方式：fs.read读取文件、正则匹配替换文本、fs.write写入文件 利用ast进行转换 如何练习的心得强化Parser API的训练有助于加强对语法树的认知，拿到一段代码就可以画在心里画出语法树，那么ast的掌握就差不多了。 自己随机写了几个常见的代码段，可以练习自己写出语法树，然后去ast explorer上验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var im100 = 100var imtrue = truevar imobject = &#123; childKey: 'childVal' &#125;var imarray = [1, 2, 3, 4, 5]// FunctionDeclarationfunction add (x, y) &#123; return x + y&#125;// VariableDeclarationconst sub = (x, y) =&gt; &#123; return x - y&#125;// BlockStatement&#123; const bs = 100&#125;// IfStatementif (im100 === 100) &#123; const is = 100&#125;// ForStatementfor (let i = 0; i &lt; 10; i++) &#123; console.log(i)&#125;// key ForInStatementfor (let item in imobject) &#123; console.log(item)&#125;// 枚举value ForOfStatementfor (let item of imarray) &#123; console.log(item)&#125;// TryStatementtry &#123; console.log(und)&#125; catch (error) &#123; // CatchClause throw new Error(error) // ThrowStatement&#125;// SwitchStatementswitch (a) &#123; case 10: console.log(a) break // BreakStatement default: console.log('ok') break&#125;// ExpressionStatementthis.axiosFetch(this.formData).then(res =&gt; &#123; this.loading = false this.handleClose()&#125;).catch(() =&gt; &#123; this.loading = false&#125;) 拿最后一段promise异步代码段举个例子，以注释的方式进行分析，当然画图更直观。 1234567891011121314151617181920212223242526272829303132333435363738// 源码段this.axiosFetch(this.formData).then(res =&gt; &#123; this.loading = false this.handleClose()&#125;).catch(() =&gt; &#123; this.loading = false&#125;)//语法树分析/** * 1 - this.axiosFetch().then().catch() ---- expressionStatement * 2 - [this.axiosFetch().then()].catch(() =&gt; &#123;this.loading = false&#125;) ---- callExpression * * [this.axiosFetch().then().catch] ---- callee: memberExpression * * () =&gt; &#123;this.loading = false&#125; ---- arguments: arrowFunctionExpression * * () ---- params: [] * * &#123;this.loading = false&#125; ---- blockStatement * * * this.loading = false ---- expressionStatement * * * this.loading = false ---- assignmentExpression * * * * * * this.loading ---- left: memberExpression * * * * * * * this ---- object: thisExpression * * * * * * * loading ---- property: identifier * * * * * * false ---- right: literal * * catch(() =&gt; &#123;this.loading = false&#125;) ---- callExpression * 3 - [this.axiosFetch()].then(res =&gt; &#123; this.loading = false; this.handleClose() &#125;) ---- callExpression * * [this.axiosFetch()] ---- callee * * then(res =&gt; &#123; this.loading = false; this.handleClose() &#125;) ---- callExpression * * * * res =&gt; &#123; this.loading = false; this.handleClose() &#125; ---- arrowFunctionExpression * * * * * res ---- blockStatement * * * * * &#123; this.loading = false; this.handleClose() &#125; ---- blockStatement * * * * * * this.loading = false ---- binaryExpression * * * * * * * this ---- thisExpression * * * * * * * loading ---- identifiy * * * * * * this.handleClose() ---- callExpression * * * * * * * this ---- thisExpression * * * * * * * handleClose() ---- callExpression * 4 - this.axiosFetch() ---- callExpression * * * * * * this ---- thisExpression * * * * * * axiosFetch() ---- callExpression */ AST实践别担心，很简单，循序渐进，用recast创造目标代码段 要实现的一段箭头函数的声明，如下面这种 123var add = (a, b) =&gt; &#123; return a + b;&#125;; 语法树分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const o = &#123; program: &#123; body: &#123; type: 'VariableDeclaration', kind: 'var', declarations: [ &#123; type: 'variableDeclarator', id: &#123; type: 'Identifier', name: 'add' &#125;, init: &#123; type: 'ArrowFunctionExpression', params: [&#123; type: 'Identifier', name: 'a' &#125;, &#123; type: 'Identifier', name: 'b' &#125;], body: &#123; type: 'BlockStatement', body: [&#123; type: 'ReturnStatement', arguments: &#123; type: 'BinaryExpression', operator: '+', left: &#123; type: 'Identifier', name: 'a' &#125;, right: &#123; type: 'Identifier', name: 'b' &#125; &#125; &#125;] &#125; &#125; &#125; ] &#125;, sourceType: 'script' &#125;&#125; 语法树parser完事就知道如何逆向构建源代码 手撸实现首先我们需要从recast.types.builders里找一些构建工具，下面的parse api都是语法树parser分析阶段出现的 12345678910const recast = require('recast')const &#123; identifier: id, variableDeclaration, variableDeclarator, binaryExpression, returnStatement, arrowFunctionExpression, blockStatement&#125; = recast.types.builders 新建一个空ast 1let ast = recast.parse() 逆向构建实现，api从这里找ast-types-builders.ts 1234567891011const astBody = variableDeclaration('var', [ variableDeclarator(id('add'), arrowFunctionExpression([id('a'), id('b')], blockStatement([ returnStatement( binaryExpression('+', id('a'), id('b')) ) ]) ) )]) 将构建好的ast对象body赋值给空的ast对象body，打印可以得到目标代码段 1234567ast.program.body[0] = astBodylet output = recast.print(ast).codeconsole.log(output)// 输出// var add = (a, b) =&gt; &#123;// return a + b;// &#125;; 这样的话，将里面的常量替换成其他ast对象上摘下来的变量就可以做很多事情。 比如将普通命名函数变成声明箭头函数 1234567function anyFnName (anyParams)&#123;true // return paramsBinaryExpression&#125;// transform =&gt;var anyFnName = (anyParams)=&gt;&#123; // return paramsBinaryExpression&#125; 用到上面的代码段构建函数，如果函数体的blockstatement不变的话，就非常简单了，直接赋值给arrowFunctionExpression 123456789101112131415161718192021222324const recast = require('recast')const &#123; variableDeclaration, variableDeclarator, arrowFunctionExpression&#125; = recast.types.buildersrecast.run(function (ast, printSource) &#123; recast.visit(ast, &#123; visitFunctionDeclaration (path) &#123; const &#123; node &#125; = path const &#123; id: functionDeaclareId, params: functionDeaclareParams, body: functionDeaclareBody &#125; = node // 用到上面的代码段构建函数 let newAstBody = variableDeclaration('var', [ variableDeclarator(functionDeaclareId, arrowFunctionExpression(functionDeaclareParams, functionDeaclareBody) ) ]) path.replace(newAstBody) return false &#125; &#125;) console.log(printSource(ast))&#125;)// 输出声明的箭头函数 做法比较简单，可能复杂点还涉及ast对象的校验以及blockstatement里面代码行判断和修改，总之理论上可以实现任意代码的转换。 AST Explorer选择合适的parser进行js代码语法树的查看工具平台，可以支持所有的es6新特性转换。 Paste or drop some JavaScript here and explore the syntax tree created by chosen parser. You can use all the cool new features from ES6 and even more syntax &amp; statements &amp; expressions语法（syntax） 、语句（statements）、表达式语句（expression statements）、 表达式（expressions）之间的关系 任何语句存在的地方都可以使用一个表达式或者代替，这叫做表达式语句（expression statements）；但是表达式存在的地方往往不可以使用语句代替或者使用语句。 syntax 语法 statements语句 expression statements 表达式语句 expressions 表达式 Statement 通常一个语句是为了完成某个任务可以独立存在的 expressions 表达式会生产一个值，使用表达式的地方期望得到一个值 1234567//全是Statementvar x;if (y &gt;= 0) &#123; x = y;&#125; else &#123; x = -y;&#125; 12// (y &gt;= 0 ? y : -y) 是expressionsvar x=(y &gt;= 0 ? y : -y) 常用AST对象Statement（语句）123456789101112131415161718BlockStatementEmptyStatementExpressionStatementIfStatementLabeledStatementBreakStatementContinueStatementWithStatementSwitchStatementReturnStatementTryStatementThrowStatementWhileStatementDoWhileStatementForInStatementForOfStatementLetStatementDebuggerStatement 接口 12345678910111213141516171819interface BlockStatement &lt;: Statement &#123; type: \"BlockStatement\"; body: [ Statement ];&#125;interface ExpressionStatement &lt;: Statement &#123; type: \"ExpressionStatement\"; expression: Expression;&#125;interface ReturnStatement &lt;: Statement &#123; type: \"ReturnStatement\"; argument: Expression | null;&#125;interface ForInStatement &lt;: Statement &#123; type: \"ForInStatement\"; left: VariableDeclaration | Expression; right: Expression; body: Statement; each: boolean;&#125; Declaration123FunctionDeclarationVariableDeclarationVariableDeclarator // 声明符 接口 1234567891011121314151617181920interface FunctionDeclaration &lt;: Function, Declaration &#123; type: \"FunctionDeclaration\"; id: Identifier; params: [ Pattern ]; defaults: [ Expression ]; rest: Identifier | null; body: BlockStatement | Expression; generator: boolean; expression: boolean;&#125;interface VariableDeclaration &lt;: Declaration &#123; type: \"VariableDeclaration\"; declarations: [ VariableDeclarator ]; kind: \"var\" | \"let\" | \"const\";&#125;interface VariableDeclarator &lt;: Node &#123; type: \"VariableDeclarator\"; id: Pattern; init: Expression | null;&#125; Expression（表达式）123456789101112131415ThisExpressionArrayExpressionObjectExpressionFunctionExpressionSequenceExpressionUnaryExpressionBinaryExpressionAssignmentExpressionLogicalExpressionConditionalExpressionNewExpressionMemberExpressionYieldExpressionComprehensionExpressiongraphExpression 接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859interface FunctionExpression &lt;: Function, Expression &#123; type: \"FunctionExpression\"; id: Identifier | null; params: [ Pattern ]; defaults: [ Expression ]; rest: Identifier | null; body: BlockStatement | Expression; generator: boolean; expression: boolean;&#125;interface ArrowExpression &lt;: Function, Expression &#123; type: \"ArrowExpression\"; params: [ Pattern ]; defaults: [ Expression ]; rest: Identifier | null; body: BlockStatement | Expression; generator: boolean; expression: boolean;&#125;interface Property &lt;: Node &#123; type: \"Property\"; key: Literal | Identifier; value: Expression; kind: \"init\" | \"get\" | \"set\";&#125;interface ThisExpression &lt;: Expression &#123; type: \"ThisExpression\";&#125;interface ObjectExpression &lt;: Expression &#123; type: \"ObjectExpression\"; properties: [ Property ];&#125;interface ArrayExpression &lt;: Expression &#123; type: \"ArrayExpression\"; elements: [ Expression | null ];&#125;interface AssignmentExpression &lt;: Expression &#123; type: \"AssignmentExpression\"; operator: AssignmentOperator; left: Pattern; right: Expression;&#125;interface ConditionalExpression &lt;: Expression &#123; type: \"ConditionalExpression\"; test: Expression; alternate: Expression; consequent: Expression;&#125;interface MemberExpression &lt;: Expression &#123; type: \"MemberExpression\"; object: Expression; property: Identifier | Expression; computed: boolean;&#125;interface CallExpression &lt;: Expression &#123; type: \"CallExpression\"; callee: Expression; arguments: [ Expression ];&#125; 其他Recast信息参考文档https://www.npmjs.com/package/ast-types https://www.npmjs.com/package/esprima https://www.babeljs.cn/docs/babel-parser https://www.babeljs.cn/docs/babel-types 原创内容，欢迎交流转载请注明出处","categories":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}],"tags":[{"name":"tag","slug":"tag","permalink":"https://joacycode.github.io/tags/tag/"}],"keywords":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}]},{"title":"你不知道的babel","slug":"2021-es-babel","date":"2020-01-27T21:34:33.000Z","updated":"2021-09-26T02:00:01.911Z","comments":true,"path":"posts/97b701ae/","link":"","permalink":"https://joacycode.github.io/posts/97b701ae/","excerpt":"","text":"当你在使用babel的时候是否只知道webpack里的babel-loader,以及极不情愿的babel-polyfill(很不幸的告诉你这个已经弃用了 如果你使用稍微高一点的babel版本)，或者知道babel的配置文件放在工程的根目录，以及使用es2015以及stage0-4这种preset（又很不幸这个又已经是过时产品）。当你对babel的理解只停留在babel-loader那么很快就会被一大堆babel相关的概念弄晕，加上webpack4之前的一大堆配置，从0-1去搭建项目只能依靠前人已经搭建好的脚手架了。本文不深都是你知道或者不知道的基础概念，从配置项入手再延伸到新旧对比，知道哪些已经是弃用的，了解哪些就可以解决绝大数基础项目的转义问题。 配置文件第一种方式，在项目的根目录创建配置文件，babel.config.json（推荐）或者 .babelrc，在其中填入如下内容： 1234&#123; \"presets\": [...], \"plugins\":[...]&#125; 第二种方式，也可以直接在package.json里加入babel的配置 12345678&#123; \"name\": \"my-package\", \"version\": \"1.0.0\", \"babel\": &#123; \"presets\": [ ... ], \"plugins\": [ ... ], &#125; &#125; 针对上述配置中常用的两个配置字段Plugins和Preset。在使用Babel（构建工具、CLI、Broswer Script）常见的配置项。 Plugins告诉Babel如何进行转换，分为转义插件和语法相关插件。 语法插件（Syntax Plugins）仅允许 Babel 解析特定类型的语法，而不具备转换能力，负责把源码(包含JS解析器不能解析的奇怪语法)解析成 AST。 命名方式为plugin-syntax-* 转义插件（Transform Plugins）会对AST进行转义，把新特性转换成目前合法标准的语法，其会自动启用语法插件进行AST解析。转义插件根据命名方式还分为： plugin-transform-*- 该转义插件转换的是Stage 4或者正式发布的特性。 plugin-proposal-* - 该转义插件转换的不是年度正式发布的特性，也就是Stage 0-3，该插件的转换特性一旦升到Stage 4以及之后阶段，那么名称是会发生变化的。 用法：@babel/plugin-xxx以箭头函数转换的插件@babel/plugin-transform-arrow-functions ，介绍插件的安装配置和用法。 安装1npm i -S @babel/plugin-transform-arrow-functions 使用声明1、通过配置文件配置文件主要指的是，上文提到的项目根目录的babel.config.json 或者 .babelrc.json文件，用配置文件方式来进行Babel使用一直都是官方推荐的一种方式。 不需要配置参数 123&#123; \"plugins\": [\"@babel/plugin-transform-arrow-functions\"] &#125; 需要配置参数，这和单个Preset的配置方式一样 12345&#123; \"plugins\": [ [\"@babel/plugin-transform-arrow-functions\", &#123; \"spec\": true &#125;] ]&#125; 名字既可以是node_modules中插件的名字，也可以是绝对地址如./node_modules/dist/plugin 需要注意的是，如果配置中同时存在Presets和Plugins，Plugins会比Presets优先执行，Plugins中插件是按顺序执行，Presets里的预设则是逆向执行（根据用户习惯确保向后兼容性，大多数用户习惯把常用的如”es2015”写在不常用的如”stage-0”前面，那么按照顺序执行就有问题，”es2015”转换不了”stage-0”的语法）。 2、通过命令行交互使用1babel --plugins @babel/plugin-transform-arrow-functions test.js 以上命令使用的前提是，你的设备中需要全局安装babel，包括@babel/core @babel/cli等，但是不推荐全局安装以及使用，下文会说明原因以及推荐的cli用法。 3、通过Node API使用1234var babel = require(\"@babel/core\")babel.transform(\"x=&gt;2x\", &#123; plugins: [\"@babel/plugin-transform-arrow-functions\"]&#125;); 上面就是直接调用@babel/core的transform方法进行字符串的转义，在第二个参数进行转义配置。@babel/core的介绍下文会进一步提及。 4、plugin简写如果preset安装包是以babel-plugin-作为前缀命名的，你就可以使用它的简写（同样适用于scoped packages）： 12345678&#123; \"presets\": [ \"myPlugin\", \"babel-plugin-myPlugin\", // 1、2相等 \"@babel/myPlugin\", \"@babel/plugin-myPlugin\",// 3、4相等 ]&#125; #### 输入输出输入 12345678var bob = &#123; _name: \"Bob\", _friends: [\"Sally\", \"Tom\"], printFriends() &#123; this._friends.forEach(f =&gt; console.log(this._name + \" knows \" + f)); &#125;&#125;; 输出 12345678910var bob = &#123; _name: \"Bob\", _friends: [\"Sally\", \"Tom\"], printFriends() &#123; var _this = this; this._friends.forEach(function (f) &#123; return console.log(_this._name + \" knows \" + f); &#125;); &#125;&#125;; 这里顺便安利一个plugin，@babel/plugin-proposal-optional-chaining 不知道大家在客户端和webview桥接的时候，使用其挂载在全局的方法postMessage会不会这么写 1234567window.webkit &amp;&amp;window.webkit.messageHandlers &amp;&amp;window.webkit.messageHandlers.MobileNavi &amp;&amp;window.webkit.messageHandlers.MobileNavi.postMessage(&#123; 'method': 'configNavigationBar', 'params': JSON.stringify(&#123;&#125;) &#125;) 那么如果你关注js新特性就会知道Null Propagation Operator 现在叫做Proposal-optional-chaining （空传运算符）。当时在这个还在stage1的时候就因为它特性太好用了就关注了，现在你可以使用@babel/plugin-proposal-optional-chaining 插件使用了，其目前已经到了stage4阶段，有望尽快发布，下面就是满怀已久法力无边空传的运算符的写法，是不是方便了很多。符号：?. 1234window.webkit?.messageHandlers?.MobileNavi?.postMessage?.(&#123; 'method': 'configNavigationBar', 'params': JSON.stringify(&#123;&#125;) &#125;) 更多其他的使用和 plugins列表 plugins列表 高级教程babel-plugins的开发Babel插件开发 Presets避免大量一个个增加plugin去满足转换需求，可以使用预设preset；preset在用户不用配置的情况下满足对(ES2015, ES2016, etc.)的转换要求。但如果你想要个性化配置，preset也支持进行用户自定义。 如果没有preset，那么基本实现一个babel-preset-env就需要引入下面这些plugins， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; \"@babel/helper-plugin-utils\": \"^7.8.3\", \"@babel/plugin-proposal-async-generator-functions\": \"^7.8.3\", \"@babel/plugin-proposal-dynamic-import\": \"^7.8.3\", \"@babel/plugin-proposal-json-strings\": \"^7.8.3\", \"@babel/plugin-proposal-nullish-coalescing-operator\": \"^7.8.3\", \"@babel/plugin-proposal-numeric-separator\": \"^7.8.3\", \"@babel/plugin-proposal-object-rest-spread\": \"^7.9.6\", \"@babel/plugin-proposal-optional-catch-binding\": \"^7.8.3\", \"@babel/plugin-proposal-optional-chaining\": \"^7.9.0\", \"@babel/plugin-proposal-unicode-property-regex\": \"^7.8.3\", \"@babel/plugin-syntax-async-generators\": \"^7.8.0\", \"@babel/plugin-syntax-dynamic-import\": \"^7.8.0\", \"@babel/plugin-syntax-json-strings\": \"^7.8.0\", \"@babel/plugin-syntax-nullish-coalescing-operator\": \"^7.8.0\", \"@babel/plugin-syntax-numeric-separator\": \"^7.8.0\", \"@babel/plugin-syntax-object-rest-spread\": \"^7.8.0\", \"@babel/plugin-syntax-optional-catch-binding\": \"^7.8.0\", \"@babel/plugin-syntax-optional-chaining\": \"^7.8.0\", \"@babel/plugin-syntax-top-level-await\": \"^7.8.3\", \"@babel/plugin-transform-arrow-functions\": \"^7.8.3\", \"@babel/plugin-transform-async-to-generator\": \"^7.8.3\", \"@babel/plugin-transform-block-scoped-functions\": \"^7.8.3\", \"@babel/plugin-transform-block-scoping\": \"^7.8.3\", \"@babel/plugin-transform-classes\": \"^7.9.5\", \"@babel/plugin-transform-computed-properties\": \"^7.8.3\", \"@babel/plugin-transform-destructuring\": \"^7.9.5\", \"@babel/plugin-transform-dotall-regex\": \"^7.8.3\", \"@babel/plugin-transform-duplicate-keys\": \"^7.8.3\", \"@babel/plugin-transform-exponentiation-operator\": \"^7.8.3\", \"@babel/plugin-transform-for-of\": \"^7.9.0\", \"@babel/plugin-transform-function-name\": \"^7.8.3\", \"@babel/plugin-transform-literals\": \"^7.8.3\", \"@babel/plugin-transform-member-expression-literals\": \"^7.8.3\", \"@babel/plugin-transform-modules-amd\": \"^7.9.6\", \"@babel/plugin-transform-modules-commonjs\": \"^7.9.6\", \"@babel/plugin-transform-modules-systemjs\": \"^7.9.6\", \"@babel/plugin-transform-modules-umd\": \"^7.9.0\", \"@babel/plugin-transform-named-capturing-groups-regex\": \"^7.8.3\", \"@babel/plugin-transform-new-target\": \"^7.8.3\", \"@babel/plugin-transform-object-super\": \"^7.8.3\", \"@babel/plugin-transform-parameters\": \"^7.9.5\", \"@babel/plugin-transform-property-literals\": \"^7.8.3\", \"@babel/plugin-transform-regenerator\": \"^7.8.7\", \"@babel/plugin-transform-reserved-words\": \"^7.8.3\", \"@babel/plugin-transform-shorthand-properties\": \"^7.8.3\", \"@babel/plugin-transform-spread\": \"^7.8.3\", \"@babel/plugin-transform-sticky-regex\": \"^7.8.3\", \"@babel/plugin-transform-template-literals\": \"^7.8.3\", \"@babel/plugin-transform-typeof-symbol\": \"^7.8.4\", \"@babel/plugin-transform-unicode-regex\": \"^7.8.3\"&#125; 用法：@babel/preset-xxx 。 1、官方支持的preset支持React JSX语法 @babel/preset-react 支持typescript语法 @babel/preset-typescript 满足对(ES2015, ES2016, etc.)的转换要求 @babel/preset-env 支持flow语法 @babel/preset-flow 社区还有其他的优秀preset,比如 服务于vue-cli 的@vue/babel-preset-app， 服务于Vue JSX的@vue/babel-preset-jsx 服务现代浏览器preset babel-preset-modern-browsers 服务NodeJS断言库preset babel-preset-power-assert 2、stage-X@babel/preset-stage-x 官方针对还未发布的js特性进行preset，使得一些比较前沿的js提案特性可以像已发版一样正常使用，preset-stage-x每年都会根据 TC39 会议动态变化，提案也是分阶段的，所以preset也会按照阶段进行区分。但是这个Stage Preset在Babel V7 版本中，和年份Preset（如es2015）一样，会被逐渐弃用。 拓展芝士： Stage 0 - TC39成员一些想法提案能解决或者优化现有的问题 Stage 1 - 上一阶段的一些比较靠谱而且被论证值得实现的提案 Stage 2 - 到达草案阶段 Stage 3 - 提案规范补充完整，一些浏览器已经开始支持 Stage 4 - 明确下一年度版本会添加这个阶段的更新，称为ECMAScript 标准 现有的stage0-4提案都在这 https://github.com/tc39/proposals 3、创建自定义preset只需export配置内容，包含数个已有的plugins和presets（记得在package.json中引入相应的包），publish到npm上，就可以像使用其他preset一样使用。 1234567891011// custom-preset package.json&#123; \"name\": \"babel-preset-custom-preset\", \"version\": \"1.0.0\", \"author\": \"Joacyz &lt;joacycode@163.com&gt;\", \"dependencies\": &#123; \"@babel/preset-env\": \"^6.3.13\", \"@babel/plugin-proposal-class-properties\": \"^6.3.13\", \"@babel/plugin-proposal-object-rest-spread\": \"^6.3.15\" &#125;&#125; 12345678910//custom-preset index.jsmodule.exports = () =&gt; (&#123; presets: [ require(\"@babel/preset-env\"), ], plugins: [ [require(\"@babel/plugin-proposal-class-properties\"), &#123; loose: true &#125;], require(\"@babel/plugin-proposal-object-rest-spread\"), ],&#125;); 这比自己开发Babel插件容易的多，可以参考这里开发一个自定义preset Making your own preset 如果不推送到npm，也可以在项目中使用绝对或者相对路径引用它们。 1&#123; \"presets\": [\"./myProject/custom-preset\"] &#125; 4、preset简写如果preset安装包是以babel-preset-作为前缀命名的，你就可以使用它的简写（同样适用于scoped packages）： 12345678910&#123; \"presets\": [ \"myPreset\", \"babel-preset-myPreset\", // 1、2相等 \"@aszero/myPreset\", \"@aszero/babel-preset-myPreset\",// 3、4相等 \"@babel/myPreset\", \"@babel/preset-myPreset\",// 5、6相等 ]&#125; 5、（逆向）执行顺序按照从后往前的逆向执行，确保向后兼容。比如大部分用户会把”es2015” 放在在 “stage-0”之前写，因为 “stage-0”相对于”es2015”会解析更为复杂、前沿或者说是更”不靠谱”的语法，可以理解为越靠前的preset解析就越基础、越普适。 6、preset配置1234567&#123; \"presets\": [ \"presetA\", [\"presetA\"], [\"presetA\", &#123;&#125;], //三种写法相等 ]&#125; @babel/preset-env当前官方最重要的预设，满足对(ES2015, ES2016, etc.)的智能转换要求，可以让我们使用最新的js语法特性，这里的智能指的是可以根据当前你想要满足的环境要求进行最低开销的转义适配：对于最新高版本环境已经支持了的新特性，直接采用该新特性的写法，对于低版本不支持新特性的语法的环境则自动polyfill。 preset-env依赖一些优秀的开源库如 browserslist, compat-table, and electron-to-chromium。从这些数据源获得相应的环境与JS之间的支持匹配，从而智能的进行转义和polyfill。但是过分依赖这些数据源会导致，比如一些浏览器bug没有被compat-table标记上，那么preset-env依赖的core-js就不会对这些问题进行polyfill，即使core-js已经修复了这些问题。所以core-js从v3开始，使用自己的用于提供数据支持的库core-js-compat，以确保兼容可信度。 值得注意的是，preset-env是不支持proposal阶段（stagex）的plugin的，也就是说这个预设不包含proposal的插件去支持该阶段的特性，默认不会对该阶段进行polyfill，所以如果明确要使用这个阶段的特性需要自己手动添加plugin或者修改配置。 12345678[ \"@babel/preset-env\",&#123; corejs: &#123; version: 3, proposals: true &#125; &#125;] preset-env预设常用配置（options） 1、target string | Array | { [string]: string }, defaults to {}. 用来描述你的目标运行环境，如果不存在该配置字段默认采用Browserslist的配置，Browserslist配置也没有就会默认转换所有的ES2015+的特性，这个我们开发时候要注意，转换所有的ES2015+的特性将会影响打包体积和性能。 可以用queries字符串形式（不区分大小写）你可以在这里看到query出来的设备有哪些browser queries 1&gt; 1%, last 2 versions, not ie &lt;= 8 也可以明确列出设备和版本号（不区分大小写） 1234&#123; \"iOS\": \"9\", \"Android\": \"4\" &#125; 常用安装：既需要transforming新语法，又需要polyfilling缺失的features123npm install --save-dev @babel/core @babel/cli @babel/preset-envnpm install --save @babel/polyfill 2、spec更加严格遵循规范转义，生成出来的代码质量更为优秀，但是潜在的问题是体积会更大，更为臃肿，这个参数会传递给preset下面所有的plugins，如果当前plugin支持这个参数。boolean，默认false。 3、loose松散模式转义，并不严格遵循ES6语义上的要求规范，会转义成更为简单的ES5代码，这个参数会传递给preset下面所有的plugins，如果当前plugin支持这个参数。boolean，默认false。loose模式和正常模式的转义后的区别 4、modules “amd” | “umd” | “systemjs” | “cjs” | “auto” | false 指定将ES6模块转换成其他模块类型，默认auto 5、debug 是否将preset配置信息打印出来，如果开启将会打印包括target列表，使用的plugins信息，modules，useBuiltIns，对你的哪些文件做了哪些polyfills等等。boolean，默认是false。 6、corejs 2, 3 or { version: 2 | 3, proposals: boolean }, 默认为 2 Babelv7.4开始不再推荐用 @babel/polyfill，如果在以上的版本安装会收到警告让你去直接使用core-js regenerator-runtime做polyfill。 1234567warning @babel/polyfill@7.8.7: As of Babel 7.4.0, thispackage has been deprecated in favor of directlyincluding core-js/stable (to polyfill ECMAScriptfeatures) and regenerator-runtime/runtime(needed to use transpiled generator functions): &gt; import \"core-js/stable\"; &gt; import \"regenerator-runtime/runtime\"; 所以preset-env需要你装这些包做polyfill，这里注意两点，第一core-js regenerator-runtime 是做polyfill的需要在你的源码之前运行，必须装在dependency里而非devDependency，第二preset-env默认不支持Stage 4 以下的proposals的polyfill，需要启用参数proposals: true 。 7、useBuiltIns “usage” | “entry” | false, 默认 false false 只做了语法转换，在精确知道哪些特性需要polyfill，熟悉core-js前提下，自己手动引入polyfill包也可，比如 1import \"core-js/es/promise\" entry 会注入core-js所有的 modules引用，但现实情况是绝大部分都用不上，代码体积比较大。 usage 会自动检测代码（依赖target配置）在需要的地方进行modules注入polyfill（推荐这种方式） 注意所有的polyfill注入都是基于转换后的代码。 其他Babel转换核心库 @babel/corepolyfill环境缺失特性 @babel/polyfill介绍preset-env的配置参数core-js中提到，Babelv7.4开始不再推荐用 @babel/polyfill，如果在以上的版本安装会收到警告让你去直接使用core-js regenerator-runtime做polyfill，配合preset-env进行最低开销的polyfill才是当下和未来的polyfill趋势。 所以如果使用7.4版本以上的Babel就可以暂时忽略使用这个方式polyfill，在stable的基础上尽量用新（版本）不用旧（版本）。 7.x升级方案 命令行中使用babel @babel/cli可以全局安装（global）也可以局部（locally）安装，更推荐后者。因为不同的项目在同一台机器上可能依赖的Babel版本不同，局部安装你可以单独去升级操作，而且项目环境中没有隐藏的依赖项，会让你的项目更方便独立操作。其他配置参数见文档。 1npm install --save-dev @babel/core @babel/cli @babel/preset-env 1npx babel xx.js --watch --out-file xx-compiled.js webpack中简单使用babel最基本的babel-loader @babel/core @babel/preset-env，配合配置文件进行配置以及上述的官方支持的preset列表，满足大多数转换场景的使用，流程为安装-配置-使用。 Installation1npm install --save-dev babel-loader @babel/core @babel/preset-env Usage12345678910111213&#123; module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /node_modules/, use: &#123; loader: \"babel-loader\" &#125; &#125; ] &#125;&#125; Config123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 原创内容，欢迎交流转载请注明出处","categories":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}],"tags":[{"name":"tag","slug":"tag","permalink":"https://joacycode.github.io/tags/tag/"}],"keywords":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}]},{"title":"那一年前端招人的部分笔试题","slug":"2019-record-subject","date":"2019-11-05T17:12:52.000Z","updated":"2021-09-26T02:00:01.908Z","comments":true,"path":"posts/e87e7952/","link":"","permalink":"https://joacycode.github.io/posts/e87e7952/","excerpt":"部门人员补充秋招结束，当时自己贡献的几道笔试题也可以放出来了，主要是针对T2-T5职级研发使用的。主要涉及正则运用、git使用、linux了解、webpack使用、简单css能力、前端自驱力、js基础等考察，笔试并没有对react、vue、redux等框架运用和核心原理源码的涉及，但是在面试过程中这些框架有点到面的深入沟通。","text":"部门人员补充秋招结束，当时自己贡献的几道笔试题也可以放出来了，主要是针对T2-T5职级研发使用的。主要涉及正则运用、git使用、linux了解、webpack使用、简单css能力、前端自驱力、js基础等考察，笔试并没有对react、vue、redux等框架运用和核心原理源码的涉及，但是在面试过程中这些框架有点到面的深入沟通。 前端这个职业，首先最重要的是思维（解决问题的方式），比如实现业务的方式有无数种，你选择的那种是不是最优雅、最健壮、最拓展性，100行代码能解决的业务问题，你能不能50行甚至20行就解决，顺带实现前面提到的优雅、健壮、可拓展的问题；其次是基础的深入以及扎实程度，有扎实的基础才能透过现象看本质，才能看懂各种神奇的源码，就像一个孩子手中的积木多了才有可能搭建更稳固和好玩的东西；最后才是各种框架和库的熟练使用程度，使用框架是为了提高效率，而不是为了偷懒。如果一遇到问题就想有没有api可以调，那么工作中拔高程度就很有限，做的再优秀也只是个api调用工程师。 仅供参考，每个部门不同时间笔试题都不一样，只能参考我们秋招(社)出题思路是啥样的，笔试还是回归到力库刷题吧~（=。=） 时间45分钟 使用正则去除价格小数位末尾无效’0’, 例如$90.10, $201.00, 转换成$90.1和$20112345678910111213141516let trimZero = (_price)=&gt;&#123;trueif(typeof _price !== 'string' &amp;&amp; typeof _price !== 'number' ) throw new Error('type error')truelet price = String(_price)truelet priceArr = price.split('.')truelet priceArrLen = priceArr.lengthtrueif (priceArrLen === 1) return price let reg = /0+\\b/gtruelet intPrice = priceArr[0]truelet floatPrice = priceArr[1]truelet freshFloatPrice = floatPrice.replace(reg,'')trueif(freshFloatPrice)&#123;truetruereturn intPrice+'.'+freshFloatPricetrue&#125;else&#123;truetruereturn intPricetrue&#125;&#125; 使用CSS写出实心三角形 ▲ 和一个箭头 &gt; 以及三字型状菜单图标 ≡123456789101112131415161718192021222324252627282930/* 实心 */ &#123; width: 0; height: 0; border-width: 10px; border-color: transparent transparent #000;border-style: solid;&#125;/* 箭头 */&#123;width: 10px; height: 10px; border-width: 2px; border-color: #000 #000 transparent transparent; border-style: solid;transform: rotate(45deg);&#125;/* 菜单三字图片 */&#123;width: 100px; height: 20px; background: #000; background-clip: content-box; padding: 20px 0; border-width: 20px 0; border-color: #000;border-style: solid;&#125; 写出迁移Git仓库的流程的Git命令 , 假设原git仓库地址为git.jd.com/a/migration.git, 新仓拟定为coding.jd.com/b/migration.git123456git clone –bare https://git.jd.com/a/migration.gitcd migration.gitgit push –mirror https://coding.jd.com/b/migration.gitcd ..rm -rf migration.gitgit clone https://coding.jd.com/b/migration.git Javascript 中Set, Map的用法，以及应用场景可以替代switch枚举，具有极快查找速度set不存储value,key值不能重复12Var dataMap = new Map().set(0, ‘llily’).set(1,’jim’)dataMap.get(0) 浏览器标签之间实时的通信方式Postmessage window.opener window Parent onmessage 同域名考虑使用onstorage 请将如下数组[7,[1,3],[8,[5,6,[2,4]]]] “拍平””排序”“删除最大数”, 输出数组[1,2,3,4,5,6,7]1234567891011121314151617181920const getRes = ()=&gt;&#123; const getSingleArr = (originArr)=&gt;&#123; const result = [] const generFn = (arr)=&gt; arr.map(item=&gt;&#123; if(Array.isArray(item))&#123; generFn(item) &#125;else&#123; result.push(item) &#125; &#125;) generFn(originArr) return result &#125; const singleArr = getSingleArr(a) const sortsingleArr = singleArr.sort((a,b)=&gt;&#123; return a-b &#125;) sortsingleArr.pop() return s`ortsingleArr&#125; Webpack打包构建可以采取哪些优化，提升构建速度和缩小打包体积 和Rollup的区别？很多方法，用过的优化plugin列出来，比如dllPlugin等 你最近所了解的前瞻性的前端技术或者方向有哪些？如果关注前端圈的发展，其实很简单，随便说一些东西，比如GraphQL、serverLess、webAssembly、TypeScript项目、Vue3.0、PWA、DENO、Tink等等 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[],"keywords":[]},{"title":"shell编程来实现一些自动化-基础篇","slug":"2020-shell-script","date":"2019-10-05T17:46:55.000Z","updated":"2021-09-26T01:54:02.264Z","comments":true,"path":"posts/6b76c6f6/","link":"","permalink":"https://joacycode.github.io/posts/6b76c6f6/","excerpt":"","text":"Shell 是一个用 C 语言编写的应用程序，该应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务，如可以让用户使用 Linux 命令。 Shell script，是一种为 shell 编写的脚本程序。shell 和 shell script 是两个不同的概念，加以区分。后缀名一般是.sh。 常见的Linux的shell，以及默认的解释路径如下： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） 常用的shell为前两种，bash为LinuxOS 默认的，它是 Bourne Shell （sh）的扩展。 与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。 最简单的shell脚本的文件如下： 12#!/bin/bashecho \"Hello theo !\" 其中第一行的#! 用来指定后面的shell脚本的解释程序路径，/bin/bash就是解释Shell 程序路径。 执行shell脚本现有一个shell脚本文件theo.sh 12#!/bin/bashecho \"Hello theo !\" 如果在第一行声明了解释器的路径，linux shell中可以直接使用sh命令运行shell脚本1$ sh theo.sh 作为可执行程序可以参考以前说过的chmod命令，可以改变文件的读写以及可执行权限，这里就可以把这个bash文件变成可执行文件。 12$ chmod -x ./theo.sh$ ./theo.sh 直接将文件作为解释器的参数去运行解释器12# 这种情况下不需要在文件第一行声明解释器路径$ /bin/bash ./theo.sh 在shell脚本中写命令用 ``符号或者$()包裹起来 123for file in `ls /etc`#或for file in $(ls /etc) Shell变量定义变量shell变量和熟知的其他语言的变量略微不同，如变量名不需要声明类型、不需要加特殊标识符号、变量名和值之间的等号不能有空格。命名只能使用英文字母，数字和下划线组成，首字符不能是数字。 123456#合法USER_NAME=\"theo\"#非法USER_NAME = \"theo\"100_USER_NAME=\"theo\"$USER_NAME=\"theo\" 使用变量定义过的变量前加$符号，即可使用变量。 123echo $USER_NAME#或推荐加上花括号，识别变量边界，bianecho $&#123;USER_NAME&#125; 覆盖变量变量定义之后，该变量非只读变量，就可以重新被定义覆盖原始值。只读变量不可被重新定义，否则报错。 1234567USER_NAME=\"theo\"echo $&#123;USER_NAME&#125;USER_NAME=\"TheoCode\"echo $&#123;USER_NAME&#125;#只读变量readonly USER_NAME 删除变量删除变量后变量就如同没有定义一样，输出空，注意不能删除只读变量。 1234567USER_NAME=\"theo\"_READONLY_NAME=\"theo\"unset USER_NAME#只读变量readonly _READONLY_NAME#删除只读变量 报错 unset: _READONLY_NAME: cannot unset: readonly variableunset _READONLY_NAME Shell传参与运算传参脚本有些时候需要根据shell执行人的意志传入一些动态参数，满足不同场景下的执行方案。shell的传参和获取也非常便捷，入参就在调用的该shell文件后面增加，多个参数用空格分隔；获取参数时候用$n，$0表示文件名，其他数字按顺序表示入参。 1$ sh test.sh fst sec 1234567#test.shecho \"文件名：$0\"echo \"第一个参数: $1\"echo \"第二个参数: $2\"#文件名：test.sh#第一个参数: fst#第二个参数: sec 参数 说明 $[N] 文件名以及入参信息 $@ 分别显示所有入参 $* 一个字符串显示所有入参 $# 入参数量 123456echo \"文件名：$#\"echo \"所有参数: $*\"echo \"所有参数: $@\"#文件名：2#所有参数: fst sec#所有参数: fst sec 运算符 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 123A=99B=999STRING_TEST=\"ImZero\" 算术运算符，shell中支持算术运算需要借助 expr 表达式命令或者在mac中shell使用$((表达式))，才能完成算术运算。 123VAL=`expr $A + $B`#或者VAL=$(($A + $B)) 注意 算术运算的乘法*要使用转义字符，且运算符左右两边都要留有空格。 1VAL=`expr $A \\* $B` 关系运算符，主要有相等 -eq、不相等-ne、大于(等于)-gt -ge、小于(等于)-lt -le几种关系，其中等于和不等于条件表达式可以用算术运算符表示。条件表达式需要用 []包裹。 12echo [ $A -eq $B ] # [$A == $B]echo [ $A -ne $B ] # [$A != $B] 布尔运算符，与或非，分别用-a -o !表示。 1234# 表示判断A小于100且要B大于1000是否成立echo [ $A -lt 100 -a $B -gt 1000 ]# 表示判断A小于100或B大于1000是否成立echo [ $A -lt 100 -o $B -gt 1000 ] 逻辑运算符，与或，分别用&amp;&amp; ||表示，条件逻辑运算要使用[[条件逻辑运算]]双中括号 1234# 表示判断A小于100且要B大于1000是否成立echo [[ $A -lt 100 &amp;&amp; $B -gt 1000 ]]# 表示判断A小于100或B大于1000是否成立echo [[ $A -lt 100 || $B -gt 1000 ]] 关于单中括号、双中括号其他说明：在 [] 表达式中，常见的 &gt;, &lt; 需要加转义字符，逻辑运算符 || 、&amp;&amp; ，它需要用 -a[and] –o[or] 表示。[[]] 运算符只是 [] 运算符的扩充，能够支持 &gt;, &lt; 符号运算不需要转义符，支持逻辑运算符|| &amp;&amp; ，不再使用 -a[and] –o[or] 。 字符串运算符，检测当前字符串的语法糖符号，比如字符串为不为空，字符串长度是否为0，是否相等。 1234# 检测字符串是否为空echo [$STRING_TEST] #不为空返回 true# 检测字符串长度是否为0echo [-z $STRING_TEST] #长度为0返回 true 文件测试运算符，文件测试运算符用于检测 Unix 文件的各种属性。常用的操作符如下： 操作符 说明 -d 检测文件是否是目录，如果是，则返回 true。 -f 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 -r 检测文件是否可读，如果是，则返回 true -w 检测文件是否可写，如果是，则返回 true -x 检测文件是否可执行，如果是，则返回 true -s 检测文件是否为空（文件大小是否大于0），不为空返回 true。 -e 检测文件（包括目录）是否存在，如果是，则返回 true。 Shell字符串字符串定义shell中字符串可以用单引号也可以用双引号，两者的用法还是有区别的。单引号表示字符串，内部不能包含变量，所有字符都会原样输出；双引号表示字符串，内部可以包含变量，出现转义字符。 123USER_NAME=\"theo\"USER_JOB='does something interesting'theo_JOB=\"$&#123;USER_NAME&#125; does something interesting\" 字符串方法获取字符串长度，使用方法：\\${\\#[String]}。 12USER_NAME=\"theo\"echo $&#123;#USER_NAME&#125; #输出6 提取子字符串，使用方法：${[String]:Index:Length}，从什么地方开始截取多少字符。12USER_NAME=\"theo\"echo $&#123;USER_NAME:0:2&#125; #as 查找子字符串位置，使用方法：expr index &quot;[String]&quot; [String_child]，执行命令用的``或者$()都可以。12USER_NAME=\"theo\"echo `expr index \"$USER_NAME\" z` #输出3 Shell数组shell支持一维数组，用括号来表示数组，数组元素用”空格”符号分割开 123456# 数组名=(值1 值2 ... 值n)STU_NAMES=(\"Ella\" \"Zrus\" \"Coco\")# 单独定义STU_NAMES[0]=\"Ella\"STU_NAMES[1]=\"Zrus\"STU_NAMES[2]=\"Coco\" 输出数组 1234# 输出全部echo $&#123;STU_NAMES[@]&#125;# 按下标输出 从0开始echo $&#123;STU_NAMES[n] 获取数组长度 1echo $&#123;#array_name[@]&#125; Shell函数定义函数1234[ function ] funname()&#123; action; [return int;]&#125; 注意 return后面跟数值0-255，不能超过这个范围，如果没有return，将以最后一条命令运行结果，作为返回值。 所有函数在使用前必须定义。 函数返回值在调用该函数后通过 $? 来获得，$? 仅对其上一条指令负责。 函数入参直接连在函数名后面，多个参数空格隔开。 12345678910fn()&#123; echo \"第一个函数参数：$1\" echo \"全部函数参数个数：$#\" return 249&#125;fn 1 2 3echo $?#第一个函数参数：1#全部函数参数个数：3#249 Shell流程控制if-else语句123456789if conditionthencommand1elif # else-ifthencommand2elsecommand3fi # 结束标记 for循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 输出/etc下面所有的文件1for file in `ls /etc` 顺序输出当前列表中的数字 1234for loop in 1 2 3 4 5do echo \"The value is: $loop\"done Shell注释1# echo \"单行注释\" 12345:&lt;&lt;EOFecho \"多行注释\"echo \"多行注释\"echo \"多行注释\"EOF 12345fn()&#123; echo \"多行注释\" echo \"多行注释\" echo \"多行注释\"&#125; shell中常用的linux命令readbasenamedirname 原创内容，欢迎交流转载请注明出处","categories":[{"name":"shell","slug":"shell","permalink":"https://joacycode.github.io/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://joacycode.github.io/tags/shell/"}],"keywords":[{"name":"shell","slug":"shell","permalink":"https://joacycode.github.io/categories/shell/"}]},{"title":"常见模块化规范研究记录","slug":"2020-es-modules","date":"2019-09-28T21:35:02.000Z","updated":"2021-09-26T02:26:57.501Z","comments":true,"path":"posts/e7485c24/","link":"","permalink":"https://joacycode.github.io/posts/e7485c24/","excerpt":"虽然对模块化这些规范很熟悉，因为频繁遇到所以还是重新梳理一遍，有疑问的地方做个实践论证。重点研究分析EsModule和cjs，cmd、amd、umd则会只研究基本概念和常用方案。","text":"虽然对模块化这些规范很熟悉，因为频繁遇到所以还是重新梳理一遍，有疑问的地方做个实践论证。重点研究分析EsModule和cjs，cmd、amd、umd则会只研究基本概念和常用方案。 ES Module(重点) 旨在成为浏览器和服务器通用的模块化解决方案，模块功能主要由两个命令构成：export和import。 import命令会被 JavaScript 引擎静态分析。当遇到模块加载命令import，会生成一个只读引用（ES6的模块不是对象而是值的引用），等运行时，再根据这个只读引用去被加载的模块取值。所以编译时候就引入了模块代码，而非代码运行时引入，所以无法实现执行条件加载或者字符串拼接路径之类的，这种加载称为编译时加载。 ESM的模块输出的是值的引用而非拷贝，所以内部改变变量会改变export出的值。 与CommonJs的引入关系ES Module import也可以引入Commonjs的模块，模块得使用Commonjs规范编写，后缀名为.cjs或者模块自身的package.json中设置 1\"type\": \"commonJs” 在Node环境中支持情况Node版本 &gt;=13.2.0 直接支持 Node版本 &lt;13.2.0 如12的版本添加--experimental-module ，低于12版本的则不支持 Node环境中的加载支持都需要用.mjs扩展后缀或者在package.json中设置 1\"type\": \"module\" 在浏览器环境支持情况 安全策略更严格，非同域脚本的加载受 CORS 策略限制 服务器端提供 ES Module 资源时，必须返回有效的属于 JavaScript 类型的 Content-Type 头如text/javascript 目前主流浏览器都已经对于ES Module支持。 给 script 标签添加 type=module 属性，就可以让浏览器以 ES Module 的方式加载脚本。 1234&lt;script type=module src='x' /&gt;&lt;script type=module&gt;// do something&lt;/script&gt; 针对非内联script的defer和async，无论在什么位置都不会阻塞HTML的解析，它们的区别是async是下载完立刻执行不会按照脚本在页面上的顺序，defer是按脚本的顺序执行。内联script的defer和async不生效。 module的script下载和执行同样不阻塞HTML解析器，无论内联还是外联，模块之间是按照顺序执行的。给 script 标签显式指定 async defer 行为属性。但添加defer并没有意义。 1234&lt;script type=module src='x' async &gt;&lt;/script&gt;&lt;script type=module async&gt;// do something&lt;/script&gt; 远程 script 根据 URL 作为判断唯一性的 Key，决定进行一次还是多次执行。URL 是同一路径下的模块多次加载只会进行一次执行，div#counter的data-count属性值是1 1234// a.jsconst el = document.getElementById('counter');const countNum = parseInt(el.dataset.count.trim() || 0, 10);el.dataset.count = countNum++; 123&lt;script type=module src='./a.js' async &gt;&lt;/script&gt;&lt;script type=module src='./a.js' async &gt;&lt;/script&gt;&lt;script type=module src='./a.js' async &gt;&lt;/script&gt; ES Module循环引用的问题ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，以及变量总是绑定其所在的模块。ES6根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 注意!! ES Module循环引用一定要有跳出机制，不然就会堆栈溢出，像下面这样。 1234567891011RangeError: Maximum call stack size exceeded at afn (file:///Users/aszero/sourcecode/lab/modules/a.mjs:3:20) at bfn (file:///Users/aszero/sourcecode/lab/modules/b.mjs:4:3) at afn (file:///Users/aszero/sourcecode/lab/modules/a.mjs:4:3) at bfn (file:///Users/aszero/sourcecode/lab/modules/b.mjs:4:3) at afn (file:///Users/aszero/sourcecode/lab/modules/a.mjs:4:3) at bfn (file:///Users/aszero/sourcecode/lab/modules/b.mjs:4:3) at afn (file:///Users/aszero/sourcecode/lab/modules/a.mjs:4:3) at bfn (file:///Users/aszero/sourcecode/lab/modules/b.mjs:4:3) at afn (file:///Users/aszero/sourcecode/lab/modules/a.mjs:4:3) at bfn (file:///Users/aszero/sourcecode/lab/modules/b.mjs:4:3) 举个循环应用的例子 12345678// a.mjsimport &#123; bfn &#125; from './b.mjs'export function afn () &#123; console.log('afn执行，开始调用bfn') bfn() console.log('afn执行完毕')&#125;afn() 1234567891011// b.mjsimport &#123; afn &#125; from './a.mjs'export function bfn () &#123; const randomNum = Math.random() console.log(randomNum &gt; 0.5 ? 'bfn进入条件' : 'bfn返回空') if (randomNum &gt; 0.5) &#123; // 随机跳出机制 console.log('bfn执行，开始调用afn') afn() console.log('bfn执行完毕') &#125;&#125; 上面的随机数就是循环引用的跳出机制 执行 1$ node a.mjs 打印的结果有很多种可能性，因为是根据随机数的条件随机退出的，我们取一组数据看一下运行流程 12345678afn执行，开始调用bfn // abfn进入条件 // a - bbfn执行，开始调用afn // a - bafn执行，开始调用bfn // a - b - abfn返回空 // a - b - a - b 退出机制返回空afn执行完毕 // a - b - abfn执行完毕 // a - bafn执行完毕 // a 上面可以看出ES module执行的时候是忽略import加载，模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者保证真正取值时能够取到值，只要引用是存在的，代码就能执行。 上面的字母表示了执行的流程，分析如下，首先执行afn (链路a)，调用bfn，进入bfn(链路a-b)如果满足条件进入循环引用调用afn，此时回到afn(链路a-b-a)再调用bfn，进入bfn(链路a-b-a-b)不满足进入循环引用的条件退出循环，返回空，那么上一层afn(链路a-b-a)继续执行完毕，再上一层引用这个afn的bfn(链路a-b)也执行完毕，同时引用这个bfn的afn(链路a)也执行完毕。 CommonJs (重点) 同步加载机制，常见于NodeJs。在Node环境使用module、exports、require、 filename、 dirname提供模块化支持。 CommonJS 的模块输出的是值的浅拷贝，内部改变变量不会改变exports出的值。模块就是对象（即module.exports属性），等到运行时才把模块挂载在exports之上，加载模块其实就是查找对象属性，这种加载称为运行时加载。node中模块导入require是一个内置的函数，因此只有在运行后我们才可以得知模块导出内容，无法做静态分析。 同步加载，代码在本地，加载时间基本等于硬盘读取时间。浏览器环境不支持CommonJS。 123(function(exports, require, module, __filename, __dirname) &#123; // code&#125;); exports vs module.exports module.exports 默认值为{} exports 是 module.exports 的引用 exports 默认指向 module.exports 的内存空间 require() 返回的是 module.exports 而不是 exports 若对 exports 重新赋值，则断开了 exports 对 module.exports 的指向 commonJS循环引用的问题CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。CommonJS的做法是，一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 下面我做了个图方便理解，图中序号是执行顺序。 例如 a.js引用b.js，b.js中也引用了a.js，那么a.js代码在执行到引用b.js的时候require(b.js)(图中流程2节点)，停止执行下面的代码去加载b.js并执行，在b.js中执行到又引用a.js的时候require(a.js)(图中流程4节点)，这时候a.js已经执行了多少输出b.js就引入多少(图中流程1节点输出)，b.js保持继续执行直到执行完毕(图中流程5节点)，这时候就回到a.js(图中流程6节点)加载执行b.js中断执行的地方继续执行，这时候也可以用b.js的输出值(图中流程5节点输出)。 AMD 异步加载机制，模块的加载不影响后面语句的执行。依赖部分会在执行完成之后的回调中定义。 AMD举例require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 AMD/CMD是CommonJS在浏览器端的解决方案。 12345678910111213141516171819// 网页中引入require.js及main.js&lt;script src=\"js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt;// config()指定各模块路径和引用名require.config(&#123; baseUrl: \"js/lib\", paths: &#123; \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", &#125;&#125;);// 引用模块require([\"jquery\",\"underscore\"],function($,_)&#123; // some code here&#125;);// 定义的模块本身如果也需要依赖define(['underscore'],function(_)&#123; // some code here&#125;) CMDCMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。CMD举例sea.js 1234567891011121314151617181920212223242526272829303132/** AMD写法 **/define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() &#125; &#125;);/** CMD写法 **/define(function(require, exports, module) &#123; var a = require('./a'); //在需要时申明 a.doSomething(); if (false) &#123; var b = require('./b'); b.doSomething(); &#125;&#125;);/** sea.js **/// 定义模块 math.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js'); var add = function(a,b)&#123; return a+b; &#125; exports.add = add;&#125;);// 加载模块seajs.use(['math.js'], function(math)&#123; var sum = math.add(1+2);&#125;); UMD是AMD和CommonJS的糅合，跨平台的解决方案。 AMD 模块以浏览器第一的原则发展，异步加载模块。 CommonJS 模块以服务器第一原则发展，选择同步加载。它的模块无需包装(unwrapped modules)。 这迫使人们又想出另一个更通用的模式 UMD（Universal Module Definition)，实现跨平台的解决方案。UMD 先判断支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。 1234567891011121314(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[],"keywords":[]},{"title":"你不知道的rollup","slug":"2021-pack-rollup","date":"2019-09-18T15:35:12.000Z","updated":"2021-09-26T02:00:01.912Z","comments":true,"path":"posts/7b16fe01/","link":"","permalink":"https://joacycode.github.io/posts/7b16fe01/","excerpt":"","text":"简单总结打包工具选择：应用的打包选择webpack，模块和库的打包选择rollup更为合适。 rollup的打包小体积的代码速度更快，体积更小。 安装全局安装 1$ npm install --global rollup 项目内安装 1$ npm install --save-dev rollup 当然也可以使用yarn进行安装，安装方式和npm类似。 使用rollup有两种方式，command line interface或者js api，如 1234# 使用配置文件$ rollup -c rollup.config.js# 或者命令行参数$ rollup src/index.js --file dist/index.js --format umd --name soundbarCore 命令行参数其实就是rollup的运行配置，告诉rollup如何进行运行，如入口文件，输出文件，打包输出格式以及名称等等。 配置下面就研究下rollup的配置，整个rollup的了解就基本到位了。 官方文档的配置列表里，截取了满足绝大数场景常用的配置参数，下面列举配置文件和命令行常用的配置参数。其他更多参数也很少用，如果需要可以去官网查字典。 配置文件配置12345678910111213141516171819202122232425export default &#123; input, # 入口文件 类似webpack string | string [] | &#123; [entryName: string]: string &#125; output:&#123; dir, # 输出的包所在目录，当多个包生成时候是必要的 name, # 模块名可以代表你输出的模块 在iife/umd 打包类型下使用truetruefile, # 输出文件名，在只有一个包生成时候使用 format, # 打包类型，下面详解 globals, # 配合external使用全局变量，下面详解 assetFileNames, chunkFileNames, sourcemap &#125;, plugins:[], # 强大的插件机制，下面详解 cache, # 高级用法 external, # 打包需要排除的文件、模块或者文件夹，第三方外部依赖(string | RegExp)[] | RegExp | string treeshake, # 高级用法 watch:&#123; buildDelay, chokidar, clearScreen, skipWrite, exclude, includetrue&#125; | false&#125; 配置文件中的这些配置在命令行中基本都有对应的配置参数，往往缩写较为常见，如-o 等同于file，-f等同于format等等。如果在命令行中使用这些参数，这些参数的值优先级会高于配置文件rollup.config.js，即命令行参数会覆盖掉配置文件的相同配置项。 CLI配置123456789101112-c, --config &lt;filename&gt; 指定配置文件，默认rollup.config.js-d, --dir &lt;dirname&gt; chunks目录-e, --external &lt;ids&gt; Comma-separate list of module IDs to exclude-f, --format &lt;format&gt; 输出类型 (amd, cjs, es, iife, umd, system)-g, --globals &lt;pairs&gt; Comma-separate list of `moduleID:Global` pairs-i, --input &lt;filename&gt; 入口文件-m, --sourcemap Generate sourcemap (`-m inline` for inline map)-n, --name &lt;name&gt; 输出类型选择UMD时，输出的模块名称-o, --file &lt;output&gt; 输出文件-p, --plugin &lt;plugin&gt; 指定使用的插件-v, --version rollup版本号-w, --watch Watch files in bundle and rebuild on changes inputType: string | string [] | { [entryName: string]: string } 入口文件，也是必要配置之一，可以是字符串（单入口），也可以是数组（多入口），如果output.file没有设置那么会根据入口文件进行打包输出，输出名会依据output.entryFileNames进行设定。举个例子 12345678910111213// rollup.config.jsexport default &#123; ..., // input: 'src/main-a.js', input: &#123; a: 'src/main-a.js', 'b/index': 'src/main-b.js' //注意key值写法 &#125;, output: &#123; ..., entryFileNames: 'entry-[name].js' &#125;&#125;; 如果入口文件是字符串，那么output的[name]就是文件名，如果是对象[name]就是每一个子元素的属性。 entry-b为一个文件夹，在没有指定output.file的情况下，上述配置将会按照input和entryFileNames输出 1234.├── entry-a.js└── entry-b └── index.js 当使用CLI的时候，--input如果在首参位置可以省略，在之后每个入口值之前都需要加--input 123$ rollup --format es --input src/entry1.js --input src/entry2.js# is equivalent to$ rollup src/entry1.js src/entry2.js --format es 文件名中含有空格是合法的，但是记得要用引号括起来 1$ rollup \"src/entry 1.js\" \"src/entry 2.js\" --format es output.globalsType: { [id: string]: string } | ((id: string) =&gt; string) 外部依赖包的全局变量别名配置，尤其当使用iife umd打包类型，引入了外部依赖包，要告知rollup当前模块id对应的全局变量是什么，比如引入的jquery，rollup打包之后全局使用$等同于使用jquery 123456789101112// rollup.config.jsexport default &#123; ..., external: ['jquery'], output: &#123; format: 'iife', name: 'MyBundle', globals: &#123; jquery: '$' &#125; &#125;&#125; 123var MyBundle = (function ($) &#123; // code goes here '$' means jquery&#125;($)); CLI中这么使用 1$ rollup src/main.js -g jquery:$ 本地一些不想被打包的模块也可以使用external和globals 123456789101112131415// rollup.config.jsimport path from 'path';const externalId = path.resolve( __dirname, 'src/some-local-file-that-should-not-be-bundled.js' );export default &#123; ..., external: [externalId], output: &#123; format: 'iife', name: 'MyBundle', globals: &#123; [externalId]: 'globalVariable' &#125; &#125;&#125;; output.format在不同场景中使用，采用--format参数进行包类型转换，iife适用于浏览器直接使用script标签引用，cjs是commonjs缩写适用于node环境的调用，使用require(&#39;mypkg&#39;)引入，umd兼容浏览器和node环境。 直接拉官网的列表，很简单无需翻译 amd – Asynchronous Module Definition, used with module loaders like RequireJS cjs – CommonJS, suitable for Node and other bundlers (alias: commonjs) es – Keep the bundle as an ES module file, suitable for other bundlers and inclusion as a &lt;script type=module&gt; tag in modern browsers (alias: esm, module) iife – A self-executing function, suitable for inclusion as a &lt;script&gt; tag. (If you want to create a bundle for your application, you probably want to use this.) umd – Universal Module Definition, works as amd, cjs and iife all in one system – Native format of the SystemJS loader (alias: systemjs) 在浏览器中使用 12# compile to a &lt;script&gt; containing a self-executing function ('iife')$ rollup main.js --file bundle.js --format iife 在Nodejs中使用 12# compile to a CommonJS module ('cjs')$ rollup main.js --file bundle.js --format cjs 兼容浏览器和Node.js使用场景 12# UMD format requires a bundle name$ rollup main.js --file bundle.js --format umd --name \"myBundle\" 插件(plugins)rollup和webpack不同之处在于，要使用好它的plugin，插件的作用是非常大的。 比如webpack中常见的alias，在rollup中需要使用@rollup/plugin-alias插件完成，babel的转换也是通过@rollup/plugin-babel完成的。错误的插件会被忽略。注意区分生产环境和开发环境的插件的使用，插件是可以影响打包速度的，如非生产环境就非必要使用压缩插件。 12345678910111213141516// rollup.config.jsimport resolve from '@rollup/plugin-node-resolve';import commonjs from '@rollup/plugin-commonjs';const isProduction = process.env.NODE_ENV === 'production';export default (async () =&gt; (&#123; input: 'main.js', plugins: [ resolve(), commonjs(), isProduction &amp;&amp; (await import('rollup-plugin-terser')).terser() // 按需异步引入生产环境使用terser压缩 ], output: &#123; file: 'bundle.js', format: 'cjs' &#125;&#125;))() 常用的插件列举一下 处理node_modules里第三方模块，否则可以打包成功但是报Unresolved dependencies错误，且包中没有第三方依赖。1@rollup/plugin-node-resolve 将CommonJS 模块转换成 ES6，如果使用resolve()会对node_modules引入模块处理，如果没有此插件肯定报错。1@rollup/plugin-commonjs 可以使用别名，参考wenpack的别名使用1@rollup/plugin-alias 使用babel以及babel的配置1@rollup/plugin-babel 将json文件转换成ES6，例如在引用package.json获取版本号、包名称、作者信息等等时候必须加上此插件1@rollup/plugin-json 使用typescript1@rollup/plugin-typescript 官方其实是没有这些插件的列表的，但是需要的东西总能找出来，rollup现在绝大数的插件的scope都是@rollup，所以在npmjs上搜一下这个scope就能看到几乎所有的插件。 plugins使用方式 1234567891011121314151617181920212223// rollup.config.jsimport resolve from '@rollup/plugin-node-resolve'import commonjs from '@rollup/plugin-commonjs'import alias from '@rollup/plugin-alias'import babel from '@rollup/plugin-babel'import &#123; terser &#125; from 'rollup-plugin-terser'const path = require('path')export default &#123;true..., plugins: [ commonjs(), resolve(), terser(), babel(&#123; babelHelpers: 'bundled' &#125;), alias(&#123; entries: [ &#123; find: '@core', replacement: path.resolve(__dirname, 'src/core') &#125;, &#123; find: '@lib', replacement: path.resolve(__dirname, 'src/lib') &#125;, &#123; find: '@config', replacement: path.resolve(__dirname, 'src/config') &#125; ] &#125;) ]&#125; 后面会专门开一篇研究一下如何手撸一个rollup custom plugin 原创内容，欢迎交流转载请注明出处","categories":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}],"tags":[{"name":"tag","slug":"tag","permalink":"https://joacycode.github.io/tags/tag/"}],"keywords":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}]},{"title":"浏览器标签之间的通信","slug":"2019-browser-post-message","date":"2019-08-30T17:55:00.000Z","updated":"2021-09-26T02:23:12.116Z","comments":true,"path":"posts/ad3abf2b/","link":"","permalink":"https://joacycode.github.io/posts/ad3abf2b/","excerpt":"第一种考虑的是postMessage ，方法可以安全地实现跨源通信","text":"第一种考虑的是postMessage ，方法可以安全地实现跨源通信 postmessage预备属性值window.opener返回打开当前窗口的源窗口的引用，如果当前窗口不是由其他窗口打开的，则返回null1window.opener window.parent返回当前窗口的父窗口对象，一般用在iframe对嵌入它的父窗口引用上，若无父窗口返回自身引用1window.parent window.top当前窗口的最顶层窗口1window.top window.frameElement返回嵌入当前窗口的iframe对象1window.frameElement window.frameElement 返回嵌入窗口的元素，如果未嵌入窗口，则返回null1window.frameElement window.frames 返回当前窗口中所有子窗体的数组1window.frames 通信方法 发送窗口引用目标窗口使用postmessage,目的是用来触发目标窗口message的监听事件 1originWindow.postMessage(message, targetOrigin, [transfer]); 窗口通信接受方使用onMessage 123originWindow.onmessage = (event)=&gt;&#123; console.log(event)&#125; messageEvent的值打印如下： 获取目标窗口常用的方法 引用父窗口window.parent 引用打开源窗口window.opener 引用打开源窗口window.top 监听message事件，回调参数的source字段 直接open新窗口的值 window.frames获取子框架集合 1234567891011// http://origin.comvar targetWindow = window.open('http://target.com')targetWindow.postMessage('origin data','http://target.com')// http://target.comwindow.addEventListener('message',(event)=&gt;&#123; if(event.origin !== 'http://origin.com') return // 接受到的信息 console.log(event.data) // origin data // 把event.source作为回信对象，并且把event.origin作为targetOrigin event.source.postMessage('target data',event.origin)&#125;) 使用注意:使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*；接收消息时候要验证当前消息的source来源。否则可能会导致引起跨站点脚本攻击。 localstorage第二种考虑的是localstorage，之所以用这个是因为无意中发现storage也是可以监听的，这样的话就可以通过监听当前同源的storage实现同源不同标签之间的通信刷新。调用localStorage.setItem()触发事件，但是在当前事件监听页面用此方法是不能触发事件的，必须在不同的同源标签页面，且两次更新的值不变也不会触发事件。监听事件123window.onstorage = (e) =&gt; &#123;console.log(e)&#125;// orwindow.addEventListener('storage', (e) =&gt; console.log(e)) 触发事件1localStorage.setItem('key','value') cookie还有能想到的前端实现通信的方法是使用cookie,本质上和storage是一回事，但是没有监听方法，唯一的可以实现通信的方式就是定时器轮询cookie是否更新，而且cookie也同样受限制于同源种cookie,每次发送请求携带多余的cookie增加通信负担，是一种比较低效的不推荐的方式。 websocket涉及到服务层，以前做过websocket的相关聊天工具，这个就不止是标签之间的通信，而是任意一个浏览器和浏览器之间的标签页面通信。我们可以用node启动一个websocket服务。以下简单模拟下聊天室的websocket搭建，使得连接ws服务的页面之间可以通信。 server端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 聊天ws数据接口&#123;msg,type&#125; msg[string]消息 type[string]消息类型const WebSocket = require('ws')const wsSever = new WebSocket.Server(&#123; port: 8088 &#125;)// 消息广播wsSever.broadcast = function (data) &#123; wsSever.clients.forEach(function each (client) &#123; if (client.readyState === WebSocket.OPEN) &#123; client.send(JSON.stringify(data)) &#125; &#125;)&#125;wsSever.on('connection', function connection (ws) &#123; // ws.nickName = `游客$&#123;i++&#125;` // console.log('%s 进入聊天室', ws.nickName) wsSever.broadcast(&#123; system: `$&#123;ws.nickName&#125;号进入聊天室`, type: 'system' &#125;) const exsitGroup = [] // 聊天室里所有连接的信息的昵称呈现给新加入的连接人 // wsSever.clients.forEach(function each (client) &#123; // if (client.readyState === WebSocket.OPEN &amp;&amp; client.nickName) &#123; // exsitGroup.push(client.nickName) // &#125; // &#125;) if (exsitGroup.length &gt; 0) &#123; ws.send(JSON.stringify(&#123; type: 'exsit', data: exsitGroup &#125;)) &#125; // 监听消息事件 ws.on('message', function (message) &#123; console.log(`Server Received Message:$&#123;message&#125;`) const &#123; type, data &#125; = JSON.parse(message) console.log(type, data) if (type === 'join') &#123; wsSever.broadcast(&#123; type, data &#125;) ws.nickName = data &#125; else if (type === 'chat') &#123; wsSever.broadcast(&#123; type, data: ws.nickName + '说: ' + data &#125;) &#125; &#125;) // 结束事件 ws.on('close', function (code, reason) &#123; console.log(`客户端关闭连接：code（$&#123;code&#125;），reason（$&#123;reason&#125;）`) wsSever.broadcast(&#123; type: 'quit', data: ws.nickName &#125;) &#125;)&#125;) client端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;style&gt; .chat-wrap &#123; width: 500px; height: 500px; overflow: hidden; border: 1px solid #eee; &#125; #chat&#123; height: 450px; overflow-y: hidden; overflow-x: hidden; &#125; #chat p &#123; white-space: nowrap; word-break: break-all; &#125; #chat .msg-normal&#123; font-size: 16px; color: #333 &#125; #chat .msg-system&#123; font-size: 12px; color: rgb(255, 122, 14) &#125; .user-area&#123; display: flex; height: 50px;&#125; .user-area .msg&#123;flex:4;font-size: 16px;&#125; .user-area .send&#123;flex:1;background: rgba(66, 130, 240, 0.933);color: #fff;text-align: center;line-height: 50px;cursor: pointer;&#125; .pre-info&#123;margin-bottom: 20px;&#125; &lt;/style&gt; &lt;title&gt;ws-client-chat&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"pre-info\"&gt; &lt;input type=\"text\" id=\"tyname\" class=\"tyname\" placeholder=\"请先输入昵称\"&gt; &lt;button id=\"enter\" class=\"enter\" disabled&gt;进入聊天&lt;/button&gt; &lt;/div&gt; &lt;div class=\"chat-wrap\"&gt; &lt;div id=\"chat\"&gt;&lt;/div&gt; &lt;div class=\"user-area\"&gt; &lt;input type=\"text\" id=\"msg\" class=\"msg\"&gt;&lt;div id=\"send\" class=\"send\"&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.querySelector('#tyname').addEventListener('input',(e)=&gt;&#123; if(e.target.value.length &gt;0)&#123; document.querySelector('#enter').disabled = false &#125;else&#123; document.querySelector('#enter').disabled = true &#125; &#125;) document.querySelector('#enter').addEventListener('click',(e)=&gt;&#123; e.target.disabled = true // 连接一个ws服务 var ws = new WebSocket(\"ws:localhost:8088\"); ws.onopen = function(evt) &#123; console.log(\"Connection open ...\") // 向ws发送消息 输送昵称 ws.send(JSON.stringify(&#123; data: document.querySelector('#tyname').value, type: 'join' &#125;)) &#125; // 监听服务关闭 ws.onclose = function(evt) &#123; console.log(\"Connection close ...\") &#125; // 监听服务发来的消息 ws.onmessage = function(evt) &#123; console.log( \"Client Received Message: \" + evt.data); const &#123;type, data&#125; = JSON.parse(evt.data) const chatItem = document.createElement('p') console.log(type, data) if(type === 'chat')&#123; chatItem.className = 'msg-normal' chatItem.innerHTML = data &#125;else if(type === 'system') &#123; chatItem.className = 'msg-system' chatItem.innerHTML = data &#125;else if(type === 'join') &#123; chatItem.className = 'msg-system' chatItem.innerHTML = `$&#123;data&#125;进入聊天室` &#125;else if(type === 'quit') &#123; chatItem.className = 'msg-system' chatItem.innerHTML = `$&#123;data&#125;退出聊天室` &#125;else if(type === 'exsit') &#123; chatItem.className = 'msg-system' chatItem.innerHTML = `和 $&#123;data.join(' ')&#125; 他们打声招呼吧` &#125; document.querySelector('#chat').appendChild(chatItem) &#125;; document.querySelector('#send').addEventListener('click',()=&gt;&#123; // 向ws发送消息 ws.send(JSON.stringify(&#123; data: document.querySelector('#msg').value, type: 'chat' &#125;)) document.querySelector('#msg').value = '' &#125;) // 当前标签离开事件 window.onbeforeunload = function()&#123; return '确认离开？' //输入什么无所谓，规避欺骗风险这个自定义文字弹窗已经不被厂商支持 &#125; window.onunload = function()&#123; ws.close('1000','Leave or refresh page') &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[],"keywords":[]},{"title":"你不知道的yarn","slug":"2021-yarn","date":"2019-07-11T15:36:26.000Z","updated":"2021-09-26T02:00:01.913Z","comments":true,"path":"posts/30ba4d06/","link":"","permalink":"https://joacycode.github.io/posts/30ba4d06/","excerpt":"","text":"Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，yarn的诞生是为了弥补 npm 的一些缺陷，比如提高了包安装速度（通过并行方式安装）和增加yarn.lock文件（解决了大小版本号升级的不一致性）以及更简洁友好的输出等等，但是yarn拉取还是npm仓库的包，它只是作为一个包管理工具提供了npm之外的另一种选择而已。是一条不断推动npm进步的”鲶鱼“。 安装 以前就有npm包管理器，可以通过npm全局安装yarn 1$ npm install -g yarn 通过Homebrew进行安装 1$ brew install yarn 通过shell script进行安装 1$ curl -o- -L https://yarnpkg.com/install.sh | bash -s -- --version [version] 常用命令 yarn init 初始化使用方式和npm init相同 yarn add 安装包，类似于npm install &lt;package...&gt;，注意：使用yarn add 安装一个package之后才会生成yarn.lock。 yarn install 并不会生成，lock文件是后者的非必要的安装依赖之一。 123456# 全局安装$ yarn global add &lt;package...&gt;# 安装特定版本$ yarn add &lt;package...&gt;@&lt;version&gt;# 安装依赖参数 默认安装 —S$ yarn add &lt;package...&gt; [-D|--dev][-P|--peer][-E|--exact] yarn install 安装 package.json 中所有依赖包，用法和npm类似，但是注意yarn这里的install可以省略。 123$yarn#或者$yarn install yarn publish 发布包 yarn remove 移除包 yarn run 运行指定的script命令 查看其他CLI命令 注意，yarn也可以切换镜像源，但是没有类似nrm的快速切换工具，只能手动设置源。 1$yarn config set registry https://registry.npm.taobao.org/ 查看版本和升级版本 1234# 当前使用版本$ yarn --version# 升级到最新版本, 非跨主版本升级$ yarn set version latest 工作区（workspaces） 各个workspace中的依赖包会被提到根目录的node_modules 中安装，这可以使得安装变得更快、总体的安装占用体积也更小。 如果根目录的依赖包和workspace中的依赖包版本冲突则不会被提取出来。 yarn workpace指定workspace运行yarn的命令 1$ yarn workpace &lt;workspace_name&gt; &lt;command&gt; yarn workpaces这里从workspace变成了workspaces，意味着从指定操作单个工作区变成了操作所有工作区。 列出当前项目下所有的工作区的依赖关系 1$ yarn workspaces info 每一个workspace运行yarn的命令 1$ yarn workspaces run &lt;command&gt; 配置 开启yarn的workspace模式 1$ yarn config set workspaces-experimental true package.json中加入workspaces配置，private属性一定要设置成true，保证工作区不会被发布暴露出去，存在多个工作区的工程也没有意义和必要发布。 12345\"private\": true, # the private: true is required\"workspaces\": [true\"packages/*\", # 之所以这么写 是配合learn用法 \"workspace-a\" # 常见的和当前配置文件平级的工作区文件夹名称] 如果使用lerna，则在lerna.json中配置，通过yarn去管理项目依赖（bootstrap）,会根据根目录package.json的workspaces配置。 1234567&#123; \"packages\": [ \"packages/*\" ], \"useWorkspaces\": true, \"npmClient\": \"yarn\",&#125; 管理workspaces添加或者移除一个包可以进入当前的workspace中，也可以 yarn workpace &lt;workspace_name&gt;解决 123# 进入指定的workspace再操作$ cd packages/ &lt;workspace_name&gt;$ yarn add &lt;package_name&gt; 或者直接指定要操作的工作区，指定工作区yarn workpace &lt;workspace_name&gt;再 add &lt;package_name&gt;进行命令操作12# 直接指定要操作的工作区$ yarn workpace &lt;workspace_name&gt; add &lt;package_name&gt; 示例/package.json: 1234567&#123;true\"private\": true, true\"workspaces\": [ \"workspace-a\", \"workspace-b\",true]&#125; /workspace-a/package.json: 1234567&#123; \"name\": \"workspace-a-pkgname\", \"version\": \"1.0.0\", \"dependencies\": &#123; \"cross-env\": \"5.0.5\" &#125;&#125; /workspace-b/package.json: 12345678&#123; \"name\": \"workspace-b-pkgname\", \"version\": \"1.0.0\", \"dependencies\": &#123; \"cross-env\": \"5.0.5\", \"workspace-a\": \"1.0.0\" &#125;&#125; 运行 yarn install ，所有的依赖会被放在node_modules中。 workspace-a通过symlink别名成了/node_modules/workspace-a-pkgname ，这样就可以在工程的各个工作区像引入正常的npm包一样引入本地包。我把package.json中的name和工作区的名字有所区分，用来表明node_modules使用的并不是目录的名称而是每个工作区下package.json#name，就像发布npm包一样，pkg名称是package.json#name。 执行tree -L 3，看一下目录结构 123456789├── node_modules│ ├── workspace-a-pkgname -&gt; ../workspace-a│ └── workspace-b-pkgname -&gt; ../workspace-b├── package.json├── workspace-a│ └── package.json├── workspace-b│ └── package.json└── yarn.lock 后面会结合yarn的workspaces和lerna对monorepo进行深入研究。 原创内容，欢迎交流转载请注明出处","categories":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}],"tags":[{"name":"tag","slug":"tag","permalink":"https://joacycode.github.io/tags/tag/"}],"keywords":[{"name":"categories","slug":"categories","permalink":"https://joacycode.github.io/categories/categories/"}]},{"title":"我对于同步异步和阻塞非阻塞理解","slug":"2019-es-async-block","date":"2019-05-30T16:23:30.000Z","updated":"2021-09-26T02:00:01.909Z","comments":true,"path":"posts/5ece973c/","link":"","permalink":"https://joacycode.github.io/posts/5ece973c/","excerpt":"","text":"经常遇到这些概念，有时候给刚毕业入职同学分享的时候，感觉很多还是没有理解透。后来我就做个比喻，解释这个几个概念，有时间再画个图吧。 zero去蛋糕店买蛋糕，但是蛋糕现做需要一段时间，时间不确定，时间取决于甜点师心情和订的蛋糕难度。 同步阻塞zero订完蛋糕后，甜点师没有告诉zero需要多久，zero在店里坐着干等，两眼放空不做任何事情，直到蛋糕做好，zero才走。 同步非阻塞zero订完蛋糕后，甜点师没有告诉zero需要多久，zero就去旁边的书店看书，时不时的回来看看有没有做好。这样一来读书效率肯定不高。 异步阻塞zero订完蛋糕后，甜点师立即告诉zero需要一段时间，这段时间你可以出去玩，等好了我会发微信告诉你的。但是zero选择哪也不去在店里枯等。 异步非阻塞zero订完蛋糕后，甜点师立即告诉zero需要一段时间，这段时间你可以出去玩，等好了我会发微信告诉你的。zero于是去旁边的书店看书，一段时间后蛋糕店发微信通知他取蛋糕。 总结：同异步通常也是指单线程的任务处理方式。同步任务指的是主线程上只有前一个任务处理完，才能处理后面的任务；异步任务不进入主线程执行栈（Execution Context Stack）而是任务队列（Task Queue），从而不影响主线程其他任务执行，等主线程任务执行完毕，进行事件循环（Event Loop）来观察任务队列中要执行的事件回调，如果有事件就取出相关回调放入执行栈中由主线程执行。另外还有同步异步和并发概念，感觉一样但是完全不同，注意区分。阻塞和非阻塞在上述比喻中针对是zero本身行为（任务），要不要在等待中去做其他的事情。 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[{"name":"同步异步","slug":"同步异步","permalink":"https://joacycode.github.io/tags/同步异步/"},{"name":"阻塞非阻塞","slug":"阻塞非阻塞","permalink":"https://joacycode.github.io/tags/阻塞非阻塞/"}],"keywords":[]},{"title":"基于REST风格的查询API的DSL设计[github回音壁]","slug":"2019-doc-soundbar","date":"2019-04-14T13:59:31.000Z","updated":"2021-09-26T02:00:01.908Z","comments":true,"path":"posts/a23c0926/","link":"","permalink":"https://joacycode.github.io/posts/a23c0926/","excerpt":"","text":"在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源,所谓的api查询。我们的想法是在REST中服务端决定的资源，其实也是通过客户端所给予的信息来进行反馈（资源定位和http的动作），如果客户端和服务端之间有一套约定，这个约定框架下客户端给的信息足够多，那么也可以让服务端来满足客户端的查询需求，即按需请求和按需返回，这个和GraphQL的思想是一致的。至于为什么不统一使用GraphQL，每个公司的大背景下会有每种不同的实际情况，满足多端的需求又尽快的让服务端和客户端每个人都熟悉GraphQL，成本比较大；当然在有条件的额情况下统一使用GraphQL是最好的。所以我们就想用中间层和传统的REST来改造现有数据接口，又符合GraphQL的思想，在客户端的查询条件下，满足合并模块数据、过滤筛选冗余数据，选取特定数据的需求。 查询附加符号定义 符号 定义 $&amp; 与，默认，独立逻辑符号，不与任何字符连接使用 $&#124; 或，条件满足其一即可，merge专用，独立逻辑符号，不与任何字符连接使用 $^ 非，剔除此条件下的当前数据，独立逻辑符号，不与任何字符连接使用 $. 定位深度，类似于this. 只适用于mergeRule中 $&lt; 小于，适用于数值或者数组的长度 $&gt; 大于，适用于数值或者数组的长度 $&lt;= 小于等于，适用于数值或者数组的长度 $&gt;= 大于等于，适用于数值或者数组的长度 $= 等于，默认等于条件，不必写 $!= 不等于，不等于条件成立 $&lt;&gt; 区间，适用于数值或者数组的长度 $$ 正则匹配符号，表示当前条件为正则表达式 $&amp; 查询组里条目之间的关系默认是与的关系，当B且C满足条件，A才满足条件。 123456&#123; \"A\": &#123; \"B\": \"conditionB\", \"C\": \"conditionC\" &#125;,&#125; 等价于B &amp; C $| 查询组里条目之间的是或的关系，当B或C且D满足条件，A才被提取出来，注意只有在merge规则里使用或逻辑，filter规则里不必使用或关系。 123456789&#123; \"A\": &#123; \"B\": \"conditionB\", \"$|\": &#123; \"C\": \"conditionC\", \"D\": \"conditionC\" &#125; &#125;&#125; 等价于 B | ( C &amp; D ) $^ 满足B的情况下过滤掉A字段中的C和D字段，再提取出A，$^的value为数组，数组中的值为需要排除的字段。123456&#123; \"A\": &#123; \"B\": \"conditionB\", \"$^\": [\"C\",\"D\"] &#125;&#125; 过滤A字段中的C和D字段12345&#123; \"A\": &#123; \"$^\": [\"C\",\"D\"] &#125;&#125; $&lt; $&lt;= $&gt; $&gt;= $&lt; $&lt;&gt; 适用于数值或者数组长度的比较123456&#123; \"A\": &#123; \"$&gt;=B\": 100, \"$&lt;&gt;C\": [1,100], &#125;&#125; 假设B为数值，C为数组，那么A字段中的B大于等于100且C的长度在1到100区间，就提取A字段数据。 $!= 不等于符号123456&#123; \"A\": &#123; \"B\": \"conditionB\", \"$!=C\": \"conditionC\" &#125;&#125; 如果B等于conditionB，且C不等于conditionC，那么提取A段数据。 $$ 正则匹配符号，后面的筛选条件为正则表达式数组，数组第一项为正则表达式，第二项为标志；原数据中的数据会和正则表达式进行match匹配。语法： [pattern[,flag]]```1234567```json&#123; &quot;A&quot;: &#123; &quot;B&quot;: &quot;conditionB&quot;, &quot;$$C&quot;: [&quot;/condition(?:C|D)/&quot;,&quot;g&quot;] &#125;&#125; 如果B等于conditionB，且C中含有conditionC或者conditionD，那么提取A段数据 $. 在mergeRule中定位深度，类似于this.，则只适用于mergeRule中进行查找筛选然后合并数据，不使用的该符号默认为原数据结构的根目录查找起点。1234567&#123; \"mergeGroupA\": &#123; \"$.prarent.child\"&#123; \"B\": \"conditionB\", &#125; &#125;&#125; $.prarent.child表示，在根目录下查找parent1.parent是对象则继续查找parent下的child2.parent是数组则继续查找parent里有child的子项3.如果整个链式查找出错或者找不到期望的筛选深度，则废弃该合并字段，找不到parent或者child,mergeGroupA就会被废弃，返回数据中不会存在此字段4.root &gt; prarent &gt; child 中满足B等于conditionB的child会被合并到mergeGroupA中 注意： 逻辑符号或 非 且表达逻辑关系时候，符号$| $^ $&amp;都需要作为单独的Key值写,，以便于分组，不可和字段连在一起写。 逻辑查询，为了兼顾性能，只适用于简单类型的条件比较，字符串，数值，布尔，undefined,null等，不适用于复杂类型的判断。例如以上的condition条件可以为字符串，数值，布尔值，空等，不可以为对象，函数，数组。 查询参数url [string]接口地址，必传。中间层会代理请求当前地址，按照规则将处理的数据返回，必要时需要传params作为透传参数。123&#123; \"url\": \"https://api.xx.com/client.action1\",&#125; params [object]接口相应的参数，默认为空。12345678&#123; \"url\": \"https://api.xx.com/client.action1\", \"params\":&#123; \"client\": \"wh5\", \"functionId\": \"list\", \"clientVersion\": \"10.0.0\", &#125;&#125; filterWithoutMerge [boolean]输出的过滤模块(filter)中是否要排除掉整合模块中(merge)的数据,默认值true 。例如，所有数据为A，过滤数据为F，整合数据为M，我们会在A-M的基础上再去得到F，也就是说F&#8745;M为空。123&#123; \"filterWithoutMerge\": true,&#125; mergeRule [object]需要整合的数据规则，不需要整合则不用传该参数规则为：12345&#123; merge:&#123; mergeModuleName: conditions &#125;&#125; mergeModuleName [string]分组的名称，例如你可能需要把所有的标题整合到titles的分组中，以便于你接收数据时候可以从res.merge.titles里取出你期望整合过的数据。conditions [array | object]分组整合查询条件,以原始数据的根节点为查询源点 1234567891011121314151617181920212223&#123; \"mergeRule\": &#123; \"titles\": &#123; \"$.result.list\":&#123; \"id\": [\"665,666\",\"667,668\"], \"$!=content\": \"img\" &#125; &#125;, \"skucards\": &#123; \"$.result.des\":&#123; \"type\": \"5\" &#125; &#125;, \"scrollers\": &#123; \"$.result.skus\":&#123; \"img\": \"xx.gov\", \"$|\":&#123; \"$&gt;=leftStock\": \"100\" &#125; &#125; &#125; &#125;&#125; 假设返回的原始数据设为restitles分组整合res.result.list自身或者子项中id为’665,666’或者’667,668’且content不为’img’的集合。skucards分组整合res.result.des自身或者子项中type为5的集合。scrollers分组整合res.result.skus自身或者子项中’img’为’xx.gov’，或自身或者子项的’leftStocks’的数目大于100的集合。 filterRule [object]过滤模块，基于原始接口数据进行筛选，满足条件的集合会被过滤掉。可在filterWithoutMerge中配置是否要在原始数据中排除已经整合出来的数据。语法为：1234567&#123; filterRule:&#123; path:&#123; filterName: conditions &#125; &#125;&#125; filterName [string]原始数据中存在的子项字段名称，对该子项进项处理。conditions [object | boolean]filter的对象为数组类型，conditions的目标是对数组内的子项进行处理。filter的对象为非数组类型，conditions的目标是对该filter的对象自身进行处理。简而言之，过滤对象本身为数组，则过滤条件适用于子项过滤，过滤对象为数值、字符串、布尔值、对象等则针对自身做过滤。 注意： 过滤规则内不支持$|’或’规则，因为没有必要且不符合认知 过滤规则支持数组内子项过滤，但不支持数组内子项的子项过滤， $.a.b.c 即c才能是数组,如其他需求配合merge使用 filter过滤规则分为条件过滤和非条件过滤：条件过滤： 只针对于数组，对象类型，满足Key,Value相互匹配的条件产生过滤处理。123'$.result.list': &#123; 'floorAppearance': ['articleDetailFloor_1', 'similarArticleFloor_2'] &#125; 非条件过滤： 对象中字段，没有任何条件判断，找到次过滤字段即过滤。123'$.result.config': &#123; '$^': ['head'] // 删除config中footer字段数据,无论其值是什么&#125;, 过滤list中有floorApearrence的字段，且值等于articleDetailFloor_1和等于similarArticleFloor_2的子项。 123456&#123; // **** list是数组类型，其后条件是针对子项进项筛选 **** '$.result.list': &#123; 'floorAppearance': ['articleDetailFloor_1', 'similarArticleFloor_2'] &#125;,&#125; 过滤list中有floorApearrence的字段，且值不等于articleDetailFloor_2都过滤掉。 123456&#123; // **** list是数组类型，其后条件是针对子项进项筛选 **** '$.result.list': &#123; '$!=floorAppearance': 'similarArticleFloor_2' &#125;,&#125; 过滤list中没有description的子项 123456&#123; // **** list是数组类型，其后条件是针对子项进项筛选 **** '$.result.list': &#123; 'description': 'undefined' &#125;&#125; 过滤list中含有floorApearrence字段的所有子项123456&#123; // **** list是数组类型，其后条件是针对子项进项筛选 **** '$.result.list': &#123; '$^': ['floorApearrence'] &#125;&#125; 过滤config中footer和header字段数据,无论其值是什么123456&#123; // **** config 是对象类型，其后条件对自身进行筛选 **** '$.result.config': &#123; '$^': ['footer','header'] &#125;&#125; 完整单接口请求：123456789101112131415161718192021222324252627282930313233343536module.exports = &#123; 'queryKey': 'discoveryFanAreaList', 'url': 'https://api.m.jd.com/client.action', 'params': &#123; 'client': 'wh5', 'functionId': 'discoveryFanAreaList', 'clientVersion': '10.0.0' &#125;, 'filterWithoutMerge': true, 'mergeRule': &#123; 'skusOrImgs': &#123; '$.result.list.description': &#123; 'type': '3', '$|': &#123; 'type': '2' &#125; &#125; &#125;, 'authorDetailFloors': &#123; '$.result.list': &#123; '$$floorAppearance': ['authorDetailFloor', 'g'] &#125; &#125; &#125;, 'filterRule': &#123; '$.result.list': &#123; 'floorAppearance': ['articleDetailFloor_1', 'similarArticleFloor_2'] &#125;, '$.result.config': &#123; '$^': ['head'] &#125;, '$.result': &#123; '$^': ['pageView', 'pageViewStr'] &#125; &#125;&#125; 多接口查询多接口查询的时候，需要增加每个接口的查询的关键字，以便于返回合并数据后的读取。 queryKey [string]查询关键字，用于多接口查询返回使用，单接口可选，多接口必传。完整多接口请求示例：12345678910111213141516171819202122232425262728293031323334353637383940module.exports = [&#123; 'queryKey': 'discoveryFanAreaList', 'url': 'https://api.m.jd.com/client.action', 'params': &#123; 'client': 'wh5', 'functionId': 'discoveryFanAreaList', 'clientVersion': '10.0.0' &#125;, 'filterWithoutMerge': true, 'mergeRule': &#123; &#125;, 'filterRule': &#123; &#125;&#125;, &#123; 'queryKey': 'discoveryGuessLike', 'url': 'https://api.m.jd.com/client.action', 'params': &#123; 'client': 'wh5', 'functionId': 'discoveryGuessLike', 'clientVersion': '10.0.0' &#125;, 'filterWithoutMerge': false, 'mergeRule': &#123; &#125;, 'filterRule': &#123; &#125;&#125;, &#123; 'queryKey': 'discoveryAuthorHome', 'url': 'https://api.m.jd.com/client.action', 'params': &#123; 'client': 'wh5', 'functionId': 'discoveryAuthorHome', 'clientVersion': '10.0.0' &#125;, 'filterWithoutMerge': false, 'mergeRule': &#123; &#125;, 'filterRule': &#123; &#125;&#125;] 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[],"keywords":[]},{"title":"曝光事件的发生(垂直横向)","slug":"2019-research-expose","date":"2019-04-12T14:51:56.000Z","updated":"2021-09-26T02:26:01.927Z","comments":true,"path":"posts/73c0936b/","link":"","permalink":"https://joacycode.github.io/posts/73c0936b/","excerpt":"","text":"横划滚动曝光横向滚动推荐swiper，常用于移动端网站的内容触摸滑动,是一款功能及其强大触摸滑动插件。如果使用vue可以使用vue-awesome-swiper组件，如果是横向滑动曝光，可以使用其中的事件来监听滑动位置。本次只是讨论曝光问题，更多文档内接口参考下面链接。1234567891011var mySwiper = new Swiper('.swiper-box',&#123; on:&#123; slideNextTransitionEnd: function()&#123; // 正向切换结束时执行 if(this.activeIndex &gt; 3)&#123; // 大于当前已经曝光的数目 console.log(`expo_$&#123;this.activeIndex&#125;`) &#125; &#125;, &#125;,&#125;) 具体参考资料：vue-awesome-swipervue-awesome-swiper示例swiper4.x配置选项 垂直滚动曝光需要获得当前元素距离顶部的距离，那么offsetTop是不能满足条件的，offsetTop是根据offsetParent来定的，offsetParent又是根据子元素的父元素是否有定位属性来决定,所以当前元素一直向上的父元素和祖先元素直到body都没有定位属性（position），那么直接在当前元素上取offsetTop是没有问题的，但是这怎么可能？所以就需要递归计算到body，才能正确计算出当前元素到顶的距离。1234567const getOffsetBodyTop = (el) =&gt; &#123; if (el.offsetParent.nodeName.toLowerCase() === 'body') &#123; return el.offsetTop &#125; else &#123; return el.offsetTop + getOffsetBodyTop(el.offsetParent) &#125;&#125; 接下来就是监听事件了，需要监听当前页面已滚动的高度，当前设备视口的高度，和上面提到的该元素距离顶部的距离。123456789101112const verticalExpoHandler = (el, callback) =&gt; &#123; if ((el &amp;&amp; el.className.indexOf('hasExpo') &gt; -1) || !el) return const srcollYTop = document.body.scrollTop || document.documentElement.scrollTop const viewHeight = document.body.clientHeight //当前html和body要设置成100% const offsetBodyTop = getOffsetBodyTop(el) const expoHeight = srcollYTop + viewHeight // 曝光条件 if (expoHeight &gt;= offsetBodyTop) &#123; el.className = el.className + ' hasExpo' callback &amp;&amp; callback() &#125;&#125; 12// 以下生产环境下，别忘记加节流函数哦window.addEventLisener('srcoll',verticalExpoHandler) 补充：其他方式在不同的框架下可以使用如下的方案进行曝光事件的捕获 react-waypoint vue-waypoint 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[],"keywords":[]},{"title":"移动端开发之尺寸自适应解决方案","slug":"2019-h5-dev","date":"2019-03-15T11:39:00.000Z","updated":"2021-09-26T02:15:41.604Z","comments":true,"path":"posts/5f9487fb/","link":"","permalink":"https://joacycode.github.io/posts/5f9487fb/","excerpt":"","text":"设置根元素大小，通常设计稿的设计宽度为750，也有720或者别的尺寸的，那么在这个尺寸上的所有元素的大小都是基于这个宽度来显示的，我们正常在移动端使用设备，每个设备的宽度不尽相同，所以只要按照这个比例进行缩放就可以完成所有设备的显示一致性。按照比例进行缩放，就需要使用rem，rem是根据当前页面根元素大小调整的单位，设备的屏幕改变只要改变这个根元素的大小，就可以改变页面所有元素的尺寸。以下是我两个不同时期的分析的解决思路。 初始分析解决思路获取当前屏幕的宽度1const cWidth = document.documentElement.clientWidth 1const scale = document.documentElement.clientWidth/750 当前屏幕宽度和设计稿750的比例，这个比例的用处在于知道设备页面里面的元素大小和设计稿里面尺寸之间的关系。如果这个比列是0.5，那么设计稿里面的所有元素的大小都需要除以2才是设备里面的元素真实大小。 1const realSize = (realWidth/designWidth)*designSize 划重点：那么按照这个逻辑，(realWidth/designWidth)是固定计算的，只要在写页面时候尺寸完全按照designSize来，就可以计算出得到realSize，这可是正好符合我们的预期。我们知道根元素和rem的乘积就是真实元素大小，那么把(realWidth/designWidth)作为根元素大小，designSize作为我们写页面的大小，只不过designSize要转成rem写。 这么设置根元素1root.style.fontSize = realWidth/designWidth + 'px' 如果设计稿的字体大小是50px,那么设置这个元素大小时候就应该这么写：1font-size: 50rem; 这样的话，一个750设计稿上面的一个50px大小的字体遇上一个375设备就会变成这样：1(375/750)*50 =&gt; 25px 那一个720设计稿上面的一个50px大小的字体遇上一个414设备就会变成这样：1(414/720)*50 =&gt; 28.75px 这样也算解决设计稿和实际开发的尺寸对应问题了， 总觉得在写页面的时候写这么大的rem尺寸，而根元素通常只有小数位的px很别扭。 我们如果想写成设计稿的尺寸，而且单位就要用px。 划重点：那么我们需要用px和rem的转化工具postcss-plugin-px2rem 我们在用postcss时候带上这个插件就可以了。 12345678postcss: &#123; plugins: [ px2rem(&#123; rootValue: 100 // 转化成根元素的比例 minPixelValue: 2 // 最小px转化值 &#125;) ]&#125; 1234567891011121314// inputp &#123; margin: 0 0 20px; font-size: 32px; line-height: 1.2; letter-spacing: 1px;&#125;// outputp &#123; margin: 0 0 0.2rem; font-size: 0.32rem; line-height: 1.2; letter-spacing: 0.01rem;&#125; 这样的话我们就可以根据rootValue的值(100)把根元素的设置倍数扩大。设置根元素1root.style.fontSize = (realWidth/designWidth)*rootValue + 'px' 如果设计稿的字体大小是50px,那么设置这个元素大小时候就应该这么写：1font-size: 50px; 再来一遍这个栗子，一个750设计稿上面的一个50px大小的字体遇上一个375设备就会变成这样：1(375/750)*100*0.5 =&gt; 25px 以上的font-size会被px2rem转化成0.5rem,(375/750)*100是根元素的大小也就是50px。完整代码在这里：12345678910// 设置根元素大小export const setRootFontSize = ( designWidth = 750, stdRootValue = 100) =&gt; &#123; const root = document.documentElement const scale = root.clientWidth / designWidth const resetFontSize = scale * stdRootValue + 'px' if (root.style.fontSize !== resetFontSize) &#123; root.style.fontSize = resetFontSize &#125;&#125;// 接下来就是处理webpack中的postcss-plugin-px2rem配置问题了 原理很简单，开发时候讨便宜的实现方案。 从诉求反推的分析解决思路 从诉求出发，我们的诉求是视觉稿上的标注尺寸可以直接拿过来用，不用进行转换、不用考虑上线后设备大小，自适应转换比例。 一般我们设置HTML的font-size为百分比，这里的百分比是相对浏览器默认字号值的。最典型的方案就是设置我们的HTML根元素大小为62.5%，如果这么设置那么你就认为大多数浏览器默认的字号为16px，10/16=62.5%那么你在使用1rem时候就相当于默认字号下的10px大小，以此类推1.6rem就是16px。所以当浏览器的默认字号上升到100px，你的1.6rem就相当于100px大小，我们的视图随着浏览器一起变大和变小的感觉是如此的快乐。 1234// 如需适配多种移动设备，建议使用rem。html &#123; font-size: 62.5%; &#125;//设置12px字体，这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级body &#123; font-size:16px; font-size:1.6rem; &#125; 那有人要说了，浏览器不全是16px的默认值啊，如果不是这个值，那么和视觉稿就对不准了。那么这个，可以自己解决。 推荐一个px转rem的postcss插件postcss-plugin-px2rem，可以将经过loader样式中的px单位转换成rem，默认值转换关系是1:100（rootValue: 100） 假设，某元素的size为ElePXSize，设备宽度为clientWidth；视觉大大给我们的视觉稿该元素size为visualPXSize（我们期望编码用的），视觉稿宽度为visualWidth。那么如果想让实际的元素相对大小看起来和视觉稿一致，那么下面的等式恒成立。 1ElePXSize/clientWidth = visualPXSize/visualWidth 我们知道ElePXSize是rem转化而来的,即 1ElePXSize = rootSize * EleREMSize EleREMSize则是postcss-plugin-px2rem根据我们编码size转换的（1:100），这个size就是visualPXSize，所以上述等式也就是 123ElePXSize = rootSize * EleREMSize// &lt;=&gt; 变换成ElePXSize = rootSize * (visualPXSize/100) 所以我们可以求得根元素大小rootSize 12345ElePXSize/clientWidth = visualPXSize/visualWidth// &lt;=&gt; 变换成rootSize * (visualPXSize/100)/clientWidth = visualPXSize/visualWidth// &lt;=&gt; 变换成rootSize = clientWidth*100/visualWidth // 和visualPXSize没有半毛钱关系 举个例子 视觉稿宽度为750，某sku宽度为350px，在iphone8的设备上（w: 375），此时根元素的大小已经被设置成 12// rootSize = clientWidth*100/visualWidthrootSize = 375*100/750 = 50px 123.sku&#123; width: 350px; // &lt;=&gt; width: 3.5rem&#125; 实际设备显示的大小就是 12//伪代码50px * 3.5rem = 175px 和上面一种分析过程殊途同归，完整的一套设置根元素大小： 1234567891011export const setRootFontSize = () =&gt; &#123; const PX2REM_ROOT_VAL = 100 const VISUAL_WIDTH = 750 // 这个是视觉稿宽度喔 const root = document.documentElement const scale = root.clientWidth / VISUAL_WIDTH const resetFontSize = scale * PX2REM_ROOT_VAL + 'px' const rootFontSize = root.style.fontSize if (rootFontSize !== resetFontSize) &#123; root.style.fontSize = resetFontSize &#125;&#125; 一场视觉稿和设备单位匹配的自适应缩放的革命结束了，再也不用担心设备的大小引起的匹配问题，连视觉MM走查时候对你的好感度都倍增=。= 原创内容，欢迎交流转载请注明出处","categories":[],"tags":[],"keywords":[]},{"title":"dotjs+webpack渲染研究","slug":"2019-research-dotjs-webpack","date":"2019-02-15T11:35:01.000Z","updated":"2021-09-26T02:25:18.232Z","comments":true,"path":"posts/30ac22db/","link":"","permalink":"https://joacycode.github.io/posts/30ac22db/","excerpt":"","text":"dotjs只有120行，比较轻量的模板渲染工具，也有其他的类似nunjucks art-template等等，三者都可以考虑使用感觉都不错，dotjs和nunjucks可以在浏览器和node环境里做模板引擎。当然现在的主流前端框架把这类jquery时代的东西慢慢边缘化，node环境里也可以采用同构的方式，也不是必须需要这类工具了。如果在移动端开发中都不用考虑兼容性，ie8及以上都可以使用，ie8以下拒绝提供服务=。=但是我想说，不是所有的项目都是要vue、react这样的框架去上手的，虽然用脚手架启动一个框架很容易，但是觉得没有必要，如果你能想到最快的方式就是用原生的办法搞定，比如临时需要一个页面支持，无任何拓展维护，那么这个项目就不值得用框架大费周折。主流框架一定得用，但是不能站在其他能实现方案技术的对立面，玩呗~ 北交委提醒您：实现方案千万条，合适第一条 划重点： – 使用dotjs-loader进行分模块开发 – 熟悉dotjs语法 – .tpl .def后缀可以随便起，建议使用.tpl – 模块填充数据后进行拼接 template模板这部分如果不放在webpack里使用loader的话，就需要使用script标签，通过id方式获取里面的内容，再塞进去数据，就是浏览器即时渲染，查看源码部分，{ }这些插值符号都会存在。 12345678&lt;script id=\"header\" type=\"text/x-dot-template\"&gt;&lt;/script&gt;&lt;script&gt;const headTpl = doT.template(document.querySelect('#header').innerHTML)const html = headTpl(&#123; //...&#125;)&lt;/script&gt; 以下使用webpack: 不熟悉dotjs语法下面有文档传送门123456789&lt;!-- head.tpl --&gt;&#123;&#123;##def.head: &#123;&#123;? it.styleNight&#125;&#125; &lt;div class=\"head-b\"&gt;黑色主题：&#123;&#123;=it.headBlack&#125;&#125;&lt;div&gt; &#123;&#123;??&#125;&#125; &lt;div class=\"head-w\"&gt;白色主题：&#123;&#123;=it.headWhite&#125;&#125;&lt;div&gt; &#123;&#123;?&#125;&#125;#&#125;&#125;&#123;&#123;#def.head&#125;&#125; 12345678910111213&lt;!-- body.tpl --&gt;&lt;img src=\"&#123;&#123;=it.entryimg || 'http://dummyimage.com/320x180/2d8cf0/fff&amp;text=joacycode'&#125;&#125;\" width=\"100%\"/&gt;&lt;div class=\"title\"&gt;标题：&#123;&#123;=it.title&#125;&#125;&lt;/div&gt;&lt;div class=\"subtitle\"&gt;副标题：&#123;&#123;=it.subtitle&#125;&#125;&lt;/div&gt;&lt;div class=\"city\"&gt;城市：&#123;&#123;=it.city&#125;&#125;&lt;/div&gt;&lt;p&gt;商品序号&lt;/p&gt;&lt;ul class=\"skulist\"&gt;&#123;&#123;~it.list :value:index&#125;&#125;&lt;li&gt;&#123;&#123;=value&#125;&#125;&lt;/li&gt;&#123;&#123;~&#125;&#125;&lt;/ul&gt; 12345&lt;!-- footer.tpl --&gt;&#123;&#123;##def.footer: &lt;div class=\"footer\"&gt;尾部信息：&#123;&#123;=it.footer&#125;&#125;&lt;div&gt;#&#125;&#125;&#123;&#123;#def.footer&#125;&#125; controller1234// 引入模板 dotjs-loader处理后为模板函数 入参数据import bodyTplFn from './template/body.tpl'import headTplFn from './template/head.tpl'import footerTplFn from './template/footer.tpl' 1234567891011121314151617181920// 使用模板函数 const bodyHtml = bodyTplFn(&#123; title, subtitle, list, city, entryimg &#125;) // string const headHtml = headTplFn(&#123; styleNight, headBlack, headWhite &#125;) // string const footerHtml = footerTplFn(&#123; needFooter, footer &#125;) // string // 字符串模板拼接 const html = headHtml + bodyHtml + footerHtml 12// 引入axios请求工具import axios from 'axios' easy-mock设置的随机数据如下：1234567891011121314151617// 从easy-mock获取数据axios.get('https://www.easy-mock.com/mock/5c9dbda0bca325336a73bffc/mock/activity').then((res) =&gt; &#123; const &#123; data = &#123;&#125; &#125; = res const &#123; title = '', subtitle = '', list = '', styleNight = '', headBlack = '', headWhite = '', needFooter = '', footer = '', city = '', entryimg = '' &#125; = data // ...&#125;) webpack默认情况，模板中的数据必须用 it 作为引用。修改设置中的 varname，可以改变默认的变量名。还有其他可以更改的参数比如模板语法写法，控制空白字符等等12345678// dotjs-loader &#123; test: /\\.tpl$/, loader: 'dotjs-loader', options: &#123; varname: 'it' &#125; &#125; style增加css-loader scss-loader mini-css-extract-plugin node-sass.mini-css-extract-plugin用于提取压缩css到同一个文件中12345678&#123; test: /\\.scss|\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader' ]&#125; 12// 引入样式import './assets/main.scss' 最终显示结果：&lt;img width=”50%” src=’https://aszero.oss-cn-shanghai.aliyuncs.com/aszero/dotjs-done.png&gt; 使用链接：Dotjs 120行轻量化模板引擎Nunjucks 本文拓展模板引擎EasyMock 在线mock数据，基于mockjs,使用占位符可随机生成数据Webpack Config webpack 官方比较全的配置表dotjs-loader dotjs的webpack模块化loader 项目地址https://github.com/joacycode/dot-webpack 原创内容，欢迎交流转载请注明出处","categories":[{"name":"dotjs","slug":"dotjs","permalink":"https://joacycode.github.io/categories/dotjs/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://joacycode.github.io/tags/webpack/"},{"name":"dotjs","slug":"dotjs","permalink":"https://joacycode.github.io/tags/dotjs/"}],"keywords":[{"name":"dotjs","slug":"dotjs","permalink":"https://joacycode.github.io/categories/dotjs/"}]},{"title":"TS笔记梳理-类型","slug":"2019-ts-notes","date":"2019-01-26T16:04:52.000Z","updated":"2021-09-26T02:00:01.910Z","comments":true,"path":"posts/a7af7ffc/","link":"","permalink":"https://joacycode.github.io/posts/a7af7ffc/","excerpt":"","text":"全局安装typescript，目的是使用这个tsc的命令工具去做ts文件的编译工作，编译时可配置的。typescript是我们用的js的超集，也就是说它有的ts都包含，还增强增加了一些语法上的写法，比如适合大项目大团队开发的类型约束，使得弱类型的语言得到进一步的增强，个人认为越来越逼近java的写法。 1npm install -g typescript 使用tsc xx.ts即可以编译出符合配置要求的js文件，当然如果编译出错会有出错提醒，编译不通过，但是ts仍然会给你编译出js文件，只是告诉你这个文件很可能达不到不是你期望的效果而已。 可约束的类型布尔型 boolean数字 number字符串 string数组 有两种定义方式类型元素后跟[]，如number[]使用数组泛型，如Array&lt;number&gt; 元祖这个类型在js里并没有明确定义，它表示已知数量和类型的数组，如[string,number]表示可以接纳形如[&#39;age&#39;,20]这样的数组，如果数组的长度超过了现有定义的长度，那么超出的部分会从这两种类型里面选一种匹配，符合其中一种类型就可以，这叫做联合类型的匹配，这么表达string | number。 枚举这个类型在js里并没有，但是是比较好用的约束一组已知的常量的类型，枚举就像集合，集合里有的就可以用，没有的就会报错，枚举里的值有两个名字，例如数字类型的枚举里一个是数值对应一个名字，两者可以相互映射。我们表示星期用1``2``3这样的数值分别表示周一到周日，那么周一到周日的名称和数值是一一对应的。 12// 数值类型枚举enum Days &#123;MON = 1,TUE,WEN,THR,FRI,STA,SUN&#125; 枚举的值默认是从0开始的，但是可以手动重写，后面的枚举值都会依次加1。12345678910111213141516171819let monday: Days = Days.MON // 1let monday: Days = Days[1] // MON// 枚举打出来为类似下面的对象，形成相互映射let enumDays = &#123; MON:1, TUE:2, WEN:3, THR:4, FRI:5, STA:6, SUN:7, '1':'MON', '2':'TUE', '3':'WEN', '4':'THR', '5':'FRI', '6':'STA', '7':'SUN'&#125; Q：思考这个枚举类型有啥使用机会？ object表示除number，string，boolean，symbol，null或undefined之外的类型 null &amp; undefined默认情况下null和undefined是所有类型的子类型12345678function dosome(num: number)&#123; return num*num&#125;dosome() //错误// 以下都是允许的dosome(undefined)dosome(null)dosome(100) void表示没有任何类型。常用在当一个函数没有返回值时。 any任意类型,注意类型里还有一个Object类型。虽然也能表示任意类型，但是作用和any不一样。Object只能赋值，不能读取其上的任意值。12let obj: Object = &#123;name:'zhangsan'&#125;console.log(obj.name) // 错误！提示Object类型上没有name这个属性orz nevernever类型是任何类型的子类型,返回的值必须是不可能存在的值，即不可能赋值给任何一个变量，比如抛出的异常错误,注意无返回值不属于never，属于void。123456function error(message: string): never &#123; throw new Error(message);&#125;function error(message: string): never &#123; // 注意无返回值不属于never，属于void&#125; 原创内容，欢迎交流转载请注明出处","categories":[{"name":"ts","slug":"ts","permalink":"https://joacycode.github.io/categories/ts/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://joacycode.github.io/tags/typescript/"}],"keywords":[{"name":"ts","slug":"ts","permalink":"https://joacycode.github.io/categories/ts/"}]},{"title":"如何利用JS进行图片压缩","slug":"2018-es-compress-image","date":"2018-12-29T11:15:32.000Z","updated":"2021-09-26T02:00:01.902Z","comments":true,"path":"posts/584f30a/","link":"","permalink":"https://joacycode.github.io/posts/584f30a/","excerpt":"经常遇到用户上传文件的场景，大多数是图像，在满足一些业务时候需要对用户上传的图像进行前端的校验控制，比如体积、长宽、类型等，如果遇到校验不通过的情况分两种一种是阻止上传一种是帮组用户处理出合法的图片。第一种阻止上传影响用户的体验，用户还要自己找图片处理软件对着规则进行处理。第二种就需要用到前端的一些技术帮组用户处理图像，目前可以做到压缩体积、压缩宽高、改变图片类型、甚至提供裁切宽进行裁切。 关键知识点：FileReaderCanvas 关键代码：123456789101112// 以base64形式读取文件reader.readAsDataURL(file)// 读取成功回调 e.target.resultreader.onload = (e)=&gt;&#123; img.src = e.target.result &#125;// canvas画图操作，this指当前image对象，起始点在平面坐标(0,0)处，画一张目标宽高的图像 context.drawImage(file, 0, 0, Width, Height)// 转为blob对象canvas.toBlob()// 转为bae64对象canvas.toDataURL()// 图片加载完毕img.onload = ()=&gt;&#123;&#125;","text":"经常遇到用户上传文件的场景，大多数是图像，在满足一些业务时候需要对用户上传的图像进行前端的校验控制，比如体积、长宽、类型等，如果遇到校验不通过的情况分两种一种是阻止上传一种是帮组用户处理出合法的图片。第一种阻止上传影响用户的体验，用户还要自己找图片处理软件对着规则进行处理。第二种就需要用到前端的一些技术帮组用户处理图像，目前可以做到压缩体积、压缩宽高、改变图片类型、甚至提供裁切宽进行裁切。 关键知识点：FileReaderCanvas 关键代码：123456789101112// 以base64形式读取文件reader.readAsDataURL(file)// 读取成功回调 e.target.resultreader.onload = (e)=&gt;&#123; img.src = e.target.result &#125;// canvas画图操作，this指当前image对象，起始点在平面坐标(0,0)处，画一张目标宽高的图像 context.drawImage(file, 0, 0, Width, Height)// 转为blob对象canvas.toBlob()// 转为bae64对象canvas.toDataURL()// 图片加载完毕img.onload = ()=&gt;&#123;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859type CompressPrams = &#123; file: object, mimeType: string, maxWidth: number, maxHeight: number, callback: (blob: object) =&gt; any&#125;// compress.jsexport const compressImage:any = (params: CompressPrams):any =&gt; &#123; const &#123; file, mimeType = 'image/jpeg', callback, maxWidth, maxHeight &#125; = params if (maxWidth === 0 || maxHeight === 0) &#123; throw new Error('MaxWidth Or MaxHeight Is Zero') &#125; const canvas = document.createElement('canvas') const context = canvas.getContext('2d') const reader = new FileReader() const img = new Image() // 以base64形式读取文件 reader.readAsDataURL(file) // 读取成功回调 e.target.result reader.onload = (e) =&gt; &#123; img.src = e.target.result &#125; // 图片加载完毕 img.onload = function () &#123; const originWidth = this.width const originHeight = this.height let targetWidth = originWidth let targetHeight = originHeight // 计算目标宽高，如果不存在就是原始宽高 if (maxWidth &amp;&amp; maxHeight) &#123; if (originWidth / originHeight &gt; maxWidth / maxHeight) &#123; // 原始图片比限定大小比例宽 targetWidth = maxWidth targetHeight = Math.round(targetWidth * (originHeight / originWidth)) &#125; else &#123; // 原始图片比限定大小比例高或等于 targetHeight = maxHeight targetWidth = Math.round(targetHeight * (originWidth / originHeight)) &#125; &#125; if (maxWidth &amp;&amp; !maxHeight) &#123; // 限定宽来比例缩放高 targetWidth = maxWidth targetHeight = Math.round(targetWidth * (originHeight / originWidth)) &#125; if (maxHeight &amp;&amp; !maxWidth) &#123; // 限定高来比例缩放宽 targetHeight = maxHeight targetWidth = Math.round(targetHeight * (originWidth / originHeight)) &#125; canvas.width = targetWidth canvas.height = targetHeight // canvas画图操作，this指当前image对象，起始点在平面坐标(0,0)处，画一张目标宽高的图像 注意此时img.onload不是箭头函数 context.drawImage(this, 0, 0, targetWidth, targetHeight) // 转为blob对象，mimeType为 image/* canvas.toBlob((blob) =&gt; &#123; // 通过callback回调，传入文件blob对象以及压缩后的目标宽高 callback &amp;&amp; callback(blob, &#123;width: targetWidth, height: targetHeight&#125;) &#125;, mimeType) &#125;&#125; 1234567891011// controller.jsimport &#123; compressImage &#125; from 'compress.js'compressImage(&#123; file: newfile, mimeType:'image/jpeg', maxWidth: 1000, maxHeight: 1000, callback:(blob)=&gt;&#123; console.log(blob) &#125;&#125;) 原创内容，欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"FileReader","slug":"FileReader","permalink":"https://joacycode.github.io/tags/FileReader/"},{"name":"Canvas","slug":"Canvas","permalink":"https://joacycode.github.io/tags/Canvas/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"限频节流函数debounce&throttle","slug":"2018-es-debounce-throttle","date":"2018-12-01T10:54:21.000Z","updated":"2021-09-26T02:16:28.501Z","comments":true,"path":"posts/4278fedd/","link":"","permalink":"https://joacycode.github.io/posts/4278fedd/","excerpt":"lodash的function模块里有两个方法，debounce 和 throttle，可以做节流限频使用，为在某些特定的环境下做必要的优化。这两个方法了解原理后也可以自己去实现。","text":"lodash的function模块里有两个方法，debounce 和 throttle，可以做节流限频使用，为在某些特定的环境下做必要的优化。这两个方法了解原理后也可以自己去实现。 场景一 曝光埋点在一个多屏长度的页面中，A模块的A元素在出现在屏幕可视区域时候（即曝光）触发埋点事件，随即上报相应参数。思路：A模块A元素距离文档顶部的高度是固定值设为bodyOffsetTop，添加onscroll事件到window上，通过监听滚动事件，不断计算此时被卷入上去的文档高度docScrollTop,假设屏幕可视区域的高度为viewHeight。当以下条件成立的时候，我们就认为该元素是出于可曝光的区域的。 1bodyOffsetTop &lt;= docScrollTop + viewHeight 具体实现代码： 1234567891011121314151617181920//递归方式获得元素距离文档顶部真实高度，不受父元素position定位影响const bodyOffsetTop = (el)=&gt;&#123; if(el.offsetParent.nodeName.toLowerCase() === 'body')&#123; return el.offsetTop &#125;else&#123; return el.offsetTop + bodyTopOffsetTop(el.offsetParent) &#125;&#125;const verticalExpoEvent = (el,callback)=&gt;&#123; if( el &amp;&amp; el.className.indexOf('hasExpoed') &gt; -1 || !el) return const srcollyTop = document.body.scrollTop || document.documentElement.scrollTop const viewHeight = document.body.clientHeight const elBodyOffsetTop = bodyOffsetTop(el) const expoHeight = srcollyTop + viewHeight if(expoHeight &gt;= elBodyOffsetTop)&#123; el.className = el.className + ' hasExpoed' //增加曝光后不再曝光标识 callback &amp;&amp; callback() &#125;&#125;window.addEventListener('scroll',verticalExpoEvent) 以上代码可以实现功能，拿出去用看似也没有什么问题，毕竟现在的机器的都很高级嘛，处理器内存什么的依然可以有丝滑般体验。但是，作为一个有追求的严谨的coding工程师,不仅要code的出来功能还要在乎功能的高性能高可用高维护，职业素养必修课之一啊。上面的代码可以实现我们想要的功能，但是window的onscroll事件的监听是需要非常谨慎使用的，因为以像素为单位，以你滚动速度维度，以你一秒滚动一百个像素的来计算，机器需要一秒执行你的onscroll回调函数一百次，其中的计算量大多数都是无效的，非pay-load，以至于不怎么高端的机器，吃着火锅滑着屏幕的时候手机就死机了。这时候就需要在有效时候做节流解决思路： 无论以什么做触发单位，滑动速度有多快，都以固定的频率去执行监听事件。 场景二 表单合法性即时检查用户在填写表单输入时候，需要即时的对用户的输入合法性进行检测,如敏感词等思路： 使用onchange或者onkeyup做监听 限制监听keyCode范围 剪切和黏贴事件会change表单值 中文输入法处理 123456789101112131415161718192021222324252627282930313233343536// between func(function()&#123;let enLock = falseconst between = (val, x, y)=&gt;&#123; if(typeof val !== 'number' || typeof x !== 'number' || typeof y !== 'number') throw new Error('Each agru should be a number') return (val &gt;= x &amp;&amp; val &lt;= y)&#125;$el.addEventListener('keyup',(e)=&gt;&#123; if(enLock) return if( between(e.keyCode, 48, 57) || between(e.keyCode, 65, 90))&#123; console.log(e.target.value) // 合法性检查 ... &#125;&#125;)$el.addEventListener('cut',(e)=&gt;&#123; setTimeout(()=&gt;&#123;truetrueconsole.log(e.target.value) // 合法性检查 ...true&#125;,0)&#125;)$el.addEventListener('paste',(e)=&gt;&#123; setTimeout(()=&gt;&#123;truetrueconsole.log(e.target.value) // 合法性检查 ...true&#125;,0)&#125;)$el.addEventListener('compositionstart', function(e)&#123; enLock = true&#125;)$el.addEventListener('compositionend', function(e)&#123; enLock = false console.log(e.target.value) // 合法性检查 ...&#125;)&#125;)() 以上代码也可以实现功能，但还是有问题，用户在进行输入的时候，每个字符汉字都需要进行整篇的合法性检查，违背了高效性，浪费了一定的资源，我们其实只需要在用户停止输入的短时间内或者离开表单时候进行合法性检查即可。解决思路： 用户输入间隔期间或者离开之前进行检测。 Lodash中的throttle &amp; debouncedebounce 限频简单理解：在限定的时间内如果有新触发，那么上一次的触发无效，限时重新计算。限定的时间无触发或者大于限定的时间触发，都会按照正常触发执行。 throttle 节流简单理解：在限定的时间内如果有新触发，那么函数会按照限定时间间隔执行，直到限定的时间无触发或者大于限定的时间触发。 举例子有一个button $btn, 绑定click事件callback函数123$btn.addEventListener('click', callback)$btn.addEventListener('click', _.debounce(callback,1000,&#123;leading:false,trailing:true&#125;))$btn.addEventListener('click', _.throttle(callback,1000,&#123;leading:true,trailing:true&#125;)) 啥都没做 那么你点击的手速多快，这个callback函数就会被执行多少遍。debounce 做了1秒的限频，无限快的手速点击$btn，10秒后callback被执行 0 次，11秒后callback被执行1次throttle 做了1秒的限频，无限快的手速点击$btn，10秒后callback被执行 10 次 但是如果你是…闪电点击的间隔超过1秒，那么这两个限制函数对你无效。 以上场景一和场景二的代码可优化为如下：123456789101112// 曝光埋点window.addEventListener('scroll',_.throttle(verticalExpoEvent,100))// 表单合法性即时检查$el.addEventListener('keyup',_.debounce((e)=&gt;&#123; if(enLock) return if( between(e.keyCode, 48, 57) || between(e.keyCode, 65, 90))&#123; console.log(e.target.value) // 合法性检查 ... &#125;&#125;,500)) 手写实现throttle &amp; debounce实现一个throttle节流函数123456789101112131415//节流就是保证一段时间内只执行一次核心代码function throttle(fn, interval = 500) &#123; let run = true return function () &#123; if (!run) return run = false //定时器执行完成才能执行下一次 setTimeout(() =&gt; &#123; fn.apply(this, arguments); run = true; &#125;, interval) &#125;&#125;//调用举例document.addEventListener('click', throttle(fn,1000)) 实现一个debounce防抖函数12345678910111213//防抖在一定时间段的连续函数调用，只让其执行一次function debounce(fn, interval = 500) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); // 每次触发 定时器重新计时 timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;; &#125;//调用举例document.addEventListener('click', debounce(fn,1000)) 原创内容，欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"debounce","slug":"debounce","permalink":"https://joacycode.github.io/tags/debounce/"},{"name":"throttle","slug":"throttle","permalink":"https://joacycode.github.io/tags/throttle/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"Vue长笔陆续更新-vuex","slug":"2018-vue-vuex","date":"2018-11-23T15:15:55.000Z","updated":"2021-09-26T02:14:53.825Z","comments":true,"path":"posts/15f2dcfe/","link":"","permalink":"https://joacycode.github.io/posts/15f2dcfe/","excerpt":"","text":"安装12npm install -S vuenpm install -S vuex Vuexroot组件处进行store注册注入12345678910111213141516171819202122232425262728293031Vue.use(Vuex)const store = new Vuex.Store(storeParams)const storeParams = &#123; state:&#123; point: [55,90,29,66,86,85,99], count: 0 &#125; getters:&#123; pointBoder(state)&#123; const maxPoint = Math.max.apply(null, state.point) return maxPoint-20 //最高分以下20分被认为是高分的边界 &#125;, highPoints(state, getters)&#123; const pointBorder = getters.pointBoder return state.point.filter(item =&gt; item &gt; pointBorder) &#125; &#125; mutations:&#123; // 'increament'称为事件类型 对应方法称为回调函数 increament(state, &#123; baseNum = 1 &#125;)&#123; state.count += payload.baseNum &#125; &#125; actions:&#123; asyncIncreament(&#123; commit &#125;)&#123; setTimeout(()=&gt;&#123; commit('increament') &#125;,1000) &#125; &#125;&#125; Vue组件中使用状态管理数据1234this.$store.state //获取statethis.$store.getters //获取gettterthis.$store.commit(type, payload) // 提交mutation 更新statethis.$store.dispatch(type, payload) // 提交action 更新state Tips1.vue组件中展示store状态，在计算属性中并使用this.$store访问。2.Vue.use(Vuex) 并在根实例中注册store，值为new Vuex.Store(storeParams)，选项提供了一种机制将状态从根组件“注入”到每一个子组件中。3.getters可认为是store的计算属性，且和计算属性一样会根据依赖被缓存，接受state作为其第一个参数，接受其他 getter 作为第二个参数。 实现给getter传参，让getter返回一个函数即可。12345678const storeParams = &#123; getters: &#123; attachParams: (state) =&gt; (name) =&gt; &#123; return `name:$&#123;name&#125;,website:$&#123;state.site&#125;` &#125; &#125;&#125;this.$store.getters.attachParams('aszero') 4.mapState、mapGetters返回一个对象，可以使用对象展开运算符进行computed的混入。123456789import &#123; mapState , mapGetters&#125; from 'vuex'computed: &#123; ...mapGetters(&#123; hp: 'highPoints' // 把 `this.hp` 映射为 `this.$store.getters.highPoints` &#125;), ...mapState(&#123; p: 'point' // 把 `this.p` 映射为 `this.$store.state.point` &#125;)&#125; 5.mutation必须是同步函数。6.computed必须有return, 调用computed时候直接执行computed内逻辑并返回return值，computed只对data负责，data变更驱动computed更新状态。getters类似于computed，state类似于data。7.Action 提交的是 mutation，而不是直接变更状态,包含任意异步操作。action接受context参数，和store实例具有相同的属性和方法。12345678910const storeParams = &#123; actions: &#123; doSome1(context)&#123; //... &#125;, doSome2(&#123; state, getters, commit, dispath &#125;)&#123; //... &#125; &#125;&#125; 8.state、getter在vue组件的computed中调用，便于在提交状态后更新；mutation和action一般在methods中封装调用。 Vue plugins通过Vue.use全局方法使用插件1234// main.jsimport Vue from 'Vue'import VueToast from './plugins.js'Vue.use(VueToast) 插件为一个对象,内有public方法install,方法参数为构造器Vue和可选参数options。通过参数Vue可以做很多事情1.直接绑定属性方法到全局构造器上使用1Vue.dosomthing = ()=&gt;&#123;&#125; 2.绑定属性方法到Vue实例，这样可以在实例中可以通过this访问1Vue.prototype.dosomthing = ()=&gt;&#123;&#125; 3.mixin全局混入 mixin文档12345Vue.mixin(&#123; methods:&#123; dosomthing()&#123;&#125; &#125;&#125;) 4.添加资源,指令directive、过滤filter、过渡等。 自定义指令文档 过滤器文档123456789101112131415// 自定义指令// 只有bind、update勾子函数的简写，不考虑其他勾子函数Vue.directive('dosome',(el,&#123;name,value,expression,arg,modifiers&#125;,vnode,oldVnode)=&gt;&#123; console.log(JSON.stringify(&#123; el, // 指令所绑定的DOM元素 name, // 指令名，不包括 v- 前缀 value, // 指令的绑定值,计算值 expression, // 字符串形式的指令表达式 arg, // 传给指令的参数 modifiers // 包含修饰符的对象 &#125;)) &#125;)// v-dosome:foo.a.b = dosome// ------ --- --- ------// name arg mod expression 一个toast 插件例子12345678910111213141516171819//plugins.jsexport default &#123; install (Vue, options) &#123; Vue.prototype.$vueToast = (msg, timeout) =&gt; &#123; // 创建可复用可拓展的组件构造器 const Toast = Vue.extend(&#123; template: `&lt;div class=\"vue-toast-fix\"&gt;&lt;div class=\"vue-toast-content\"&gt;$&#123;msg&#125;&lt;/div&gt;&lt;/div&gt;` &#125;) // 在文档内渲染为： // new Toast().$mount('body')或 // new Toast(&#123;el:'body'&#125;) const toastTpl = new Toast().$mount().$el // 文档外渲染 document.body.appendChild(toastTpl) setTimeout(function () &#123; document.body.removeChild(toastTpl) &#125;, timeout || 2000) &#125; &#125;&#125; Vue-router路由导航 router-link被渲染成a标签 to 指定链接，对应routes里的path 12345&lt;router-link to='/index'&gt;&lt;/router-link&gt;&lt;router-link to='/discovery'&gt;&lt;/router-link&gt;&lt;router-link to='/home/vip/list'&gt;&lt;/router-link&gt;&lt;router-link to='/home/user/list/1'&gt;&lt;/router-link&gt;&lt;router-link to='/home/user/passport'&gt;&lt;/router-link&gt; 路由渲染出口12345// 默认视图&lt;router-view /&gt;// 命名视图&lt;router-view name='viewA'/&gt;&lt;router-view name='viewB'/&gt; 路由守卫 全局前置守卫 beforeEach 对应后置守卫afterEach, 无next参数只要路由发生变更就会进入勾子函数。 路由独享守卫 beforeEnter只有进入当前路由时会进入勾子函数。 组件内守卫 beforeRouteUpdate在无全局前置守卫时候，若动态路径参数渲染相同组件，组件复用的情况下，无法触发当前路由守卫。 123456789101112131415//全局前置守卫router.beforeEach((to, from, next) =&gt; &#123;&#125;)//路由独享守卫new VueRouter(&#123; routes: [&#123; path: '/home', component: HomeView, beforeEnter: (to, from, next) =&gt; &#123;&#125; &#125;]&#125;)//组件内守卫const HomeView =&#123; template:'', beforeRouteUpdate: (to, from, next) =&gt; &#123;&#125;&#125; 使用方法1234567891011121314151617181920212223242526272829303132import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter)const router = new VueRouter(&#123; routes: [&#123; // 动态路径参数，复用组件 path: '/home/:channel', component: ChannelView, beforeEnter: (to, from, next) =&gt; &#123; console.log('home路由独享守卫：', to, from) next() &#125;, // 嵌套路由，路由出口&lt;router-view&gt; 在 ChannelView 内 children:[&#123; path: 'list/:eq', component: HomeVideoListView &#125;,&#123; path: 'passport', component: HomePassportView &#125;] &#125;,&#123; path: '', components: &#123; // 这里是components viewA: IndexSideView, viewB: IndexContentView &#125; &#125;,&#123; path: '/audi', alias: ['/dengchang','/sihuan'] //别名 component: DiscoveryView &#125;]&#125;) $\broute $router$\broute 路由对象路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象$\brouter 访问全局路由器 vue文档链接vue-apivue-cli-3.0-configvuexvue-plugins 原创内容，欢迎交流转载请注明出处","categories":[{"name":"vue","slug":"vue","permalink":"https://joacycode.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://joacycode.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://joacycode.github.io/tags/vuex/"},{"name":"vue-rooter","slug":"vue-rooter","permalink":"https://joacycode.github.io/tags/vue-rooter/"},{"name":"vue-plugins","slug":"vue-plugins","permalink":"https://joacycode.github.io/tags/vue-plugins/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://joacycode.github.io/categories/vue/"}]},{"title":"webpack从0-1搭建项目实践流程","slug":"2018-pack-webpack","date":"2018-11-09T19:40:56.000Z","updated":"2021-09-26T02:00:01.907Z","comments":true,"path":"posts/ea8ce33c/","link":"","permalink":"https://joacycode.github.io/posts/ea8ce33c/","excerpt":"初始化,生成package.json1npm init -y 初始化git1git init","text":"初始化,生成package.json1npm init -y 初始化git1git init Install Node Dependency1cnpm install --save-dev webpack webpack-dev-server webpack-merge cross-env time-stamp 1cnpm install --save-dev @babel/core @babel/preset-react babel-preset-env babel-loader 1cnpm install --save-dev style-loader css-loader sass-loader postcss-loader autoprefixer cssnano postcss-preset-env node-sass file-loader url-loader package.json12345\"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.dev -d --history-api-fallback --inline --colors\", \"build\": \"npm run clean &amp;&amp; cross-env NODE_ENV=production webpack --config webpack.config.prod --progress --colors\", \"clean\": \"rm -rf dist\"&#125; .babelrc123&#123; \"presets\": [\"@babel/preset-env\",\"@babel/preset-react\"]&#125; .gitignoregit版本控制配置表12/node_modules//dist/ .npmignorenpm包发布配置表12/node_modules//src/ webpack.config.jsconfig可以通过webpack-merge拆分成base,dev,prod,moduleNwebpack configs Pluginshtml-webpack-pluginmini-css-extract-pluginzip-webpack-pluginnew webpack.ProvidePluginnew webpack.HotModuleReplacementPluginnew webpack.EnvironmentPlugin postcss.config.js12345678910module.exports = &#123; parser: 'sugarss', plugins: [ require('autoprefixer'), require('postcss-preset-env'), require('cssnano')(&#123; preset: 'default', &#125;) ]&#125; webpack.config 示例base1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const path = require('path')const webpack = require('webpack')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const devMode = process.env.NODE_ENV !== 'production'const miniExtractSass = new MiniCssExtractPlugin(&#123; filename: devMode ? 'dev.css' : 'prod.css'&#125;)module.exports = &#123; module: &#123; rules: [&#123; test: /\\.(jsx|js)$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.scss|\\.css$/, use: [ MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; minimize: true &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg|ttf|eot|woff)(\\?.*)?$/, use: [&#123; loader: 'file-loader', options: &#123; limit: 10000, name: '[name]_[hash:6].[ext]' &#125; &#125;] &#125;] &#125;, resolve: &#123; extensions: ['.js', '.jsx', '.json', '.css', '.scss'], alias: &#123; componentsPackage: path.resolve(__dirname, './src/components'), &#125; &#125;, plugins: [ miniExtractSass, new webpack.EnvironmentPlugin(['NODE_ENV']) ]&#125; dev123456789101112131415161718192021222324252627const path = require('path')const merge = require('webpack-merge')const webpack = require('webpack')const baseConfig = require('./webpack.config.base')const HtmlWebpackPlugin = require('html-webpack-plugin')const createWithHtml = new HtmlWebpackPlugin(&#123; template: './example/index.html'&#125;)module.exports = merge(baseConfig, &#123; entry: './example/index.jsx', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'dev.js' &#125;, plugins: [ createWithHtml, new webpack.HotModuleReplacementPlugin() ], devServer: &#123; contentBase: path.join(__dirname, './example'), hot: true, compress: true, port: 8088, progress: true, disableHostCheck: true &#125;, devtool: 'source-map'&#125;) prod12345678910111213const path = require('path')const merge = require('webpack-merge')const baseConfig = require('./webpack.config.base')module.exports = merge(baseConfig, &#123; context: path.join(__dirname, './src'), entry: './app/index.jsx', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'index.js', publicPath: './' &#125;, externals: &#123;&#125;&#125;) 原创内容，欢迎交流转载请注明出处","categories":[{"name":"webpack","slug":"webpack","permalink":"https://joacycode.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://joacycode.github.io/tags/webpack/"},{"name":"react","slug":"react","permalink":"https://joacycode.github.io/tags/react/"}],"keywords":[{"name":"webpack","slug":"webpack","permalink":"https://joacycode.github.io/categories/webpack/"}]},{"title":"移动端开发之charles的本地服务调试","slug":"charles","date":"2018-07-18T17:24:49.000Z","updated":"2021-09-26T02:05:52.425Z","comments":true,"path":"posts/6c907652/","link":"","permalink":"https://joacycode.github.io/posts/6c907652/","excerpt":"Charles官网mac上我一般都会用Charles作为抓包和代理映射工具 使用场景：移动端进行本地的实机调试，线上站点调试。 举个例子：我们开发搭建一个移动端页，我们最终的目的是让页面流转到移动设备上进行使用，不同的系统平台、不同的机型、不同的浏览器引擎、甚至他们各自不同的版本都可能影响兼容性和功能点正常使用。那么浏览器开发方式结束之后第一时间就需要进行真机上的开发，你不可能发一次预发环境调试一次，这样效率太低而且做法过于”愚蠢“。那么就需要在启动本地服务的方便修改的情况下，能调试线上的M所有资源。 所以这里用到映射代理，可以把A地址map到B地址。在不改变目标A地址情况下，让访问的资源转到B地址（可以是线上服务也可以是本地服务甚至是本地静态资源），这有点像DNS劫持钓鱼网站的做法，但是我们是用来本地调试方便开发，方便的代理线上地址到本地服务或者本地资源进行调试开发。 重点介绍下charles的使用，window上的fiddler原理是一样的。","text":"Charles官网mac上我一般都会用Charles作为抓包和代理映射工具 使用场景：移动端进行本地的实机调试，线上站点调试。 举个例子：我们开发搭建一个移动端页，我们最终的目的是让页面流转到移动设备上进行使用，不同的系统平台、不同的机型、不同的浏览器引擎、甚至他们各自不同的版本都可能影响兼容性和功能点正常使用。那么浏览器开发方式结束之后第一时间就需要进行真机上的开发，你不可能发一次预发环境调试一次，这样效率太低而且做法过于”愚蠢“。那么就需要在启动本地服务的方便修改的情况下，能调试线上的M所有资源。 所以这里用到映射代理，可以把A地址map到B地址。在不改变目标A地址情况下，让访问的资源转到B地址（可以是线上服务也可以是本地服务甚至是本地静态资源），这有点像DNS劫持钓鱼网站的做法，但是我们是用来本地调试方便开发，方便的代理线上地址到本地服务或者本地资源进行调试开发。 重点介绍下charles的使用，window上的fiddler原理是一样的。 普通抓包Charles和需要抓包的网络请求设备处于同一网络环境中。1.工具栏的proxy -&gt; macOS Proxy勾选就可以抓包本机的请求2.移动设备或者其他设备抓包请将网络的代理设置成手动，代理地址即为Charles软件所在设备的网络环境ip,端口一般为8888，设置完成后Charles会有弹框提醒是否允许信任之类的询问，直接选择allow，这样就可以愉快的抓其他设备的请求包来看了，这种抓包不需要安装ssl证书也可以抓https。 装本机证书装移动端证书 映射代理抓包这种不仅仅是抓包，而是一种映射代理，可以把A地址映射到B地址。在不改变A地址情况下，让访问自动跳到B地址，这有点像DNS劫持，钓鱼网站这样的做法，但是我们是用来方便开发，你可以方便的代理线上地址到本地服务或者本地资源进行调试开发。1.在工具栏的Tools-&gt;Map Remote里面进行设置即可。注意映射的地址要相同，映射的文件名也需要相同才能匹配成功，如果你映射的是AB两网站的grade2/class3/*，用Charles去映射A网站的grade2/class3/names.js到B网站的grade2/class3/ages.js，那么ages.js和names.js两者就映射不成功，不应该用grade2/class3/*，而是用grade2/class3/names.js -&gt; grade2/class3/ages.js强制一对一映射。2.这里如果要映射的地址是https的话，需要下载Charles的ssl证书到你的设备里，否则安全机制会导致映射失败，下载地址在工具栏 Help-&gt;SSL proxying里面下载本地版的和移动版的有相关的提示。 Configure your device to use Charles as its HTTP proxy on x.x.x.x:8888, then browse to chls.pro/ssl to download and install the certificate.大致意思就是移动版的需要连接代理设置端口号，参考方法1，然后访问chls.pro/ssl,就可以下载相应的证书了。流程示意图如下： HTTPS\b映射不成功看这里如果上面的ssl证书装完还是不可以映射https，那么就要在这里多进行一个操作的设置，在proxy -&gt; SSL Proxying setting里，进行需要进行https地址的配置，默认端口为443，注意这里的实测配置为*后的域名后缀地址必须为.com，其他区域或者个性域名后缀没有映射成功,如.me``.love，或许通过强制配置可以成功。配置SSL Proxying setting 移动端的控制台vconsoleNpm地址 https://www.npmjs.com/package/vconsole 可以方便的第一时间开启debug模式，在移动端查看控制台打印信息以及network和系统信息等，非常方便定位问题。唯一需要注意的是iOS8和Android 5以下的引入兼容性问题，可能会导致白屏。 类似的比较好用的工具还有Eruda。https://github.com/liriliri/eruda/blob/master/doc/README_CN.md script用法12345&lt;script src=\"&#123;CDN Url&#125;/vconsole.min.js\"&gt;&lt;/script&gt;&lt;script&gt; // init vConsole var vConsole = new VConsole();&lt;/script&gt; commonJS或者ESmod中使用1npm install -D vconsole 123import Vconsole from 'vconsole'//const Vconsole = require('vconsole')var vConsole = new VConsole() 原创内容，欢迎交流转载请注明出处","categories":[{"name":"工具","slug":"工具","permalink":"https://joacycode.github.io/categories/工具/"}],"tags":[{"name":"charles","slug":"charles","permalink":"https://joacycode.github.io/tags/charles/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://joacycode.github.io/categories/工具/"}]},{"title":"node笔记整理之HTTP模块","slug":"2018-node-http","date":"2018-04-01T11:49:47.000Z","updated":"2021-09-26T02:00:01.907Z","comments":true,"path":"posts/e41d3209/","link":"","permalink":"https://joacycode.github.io/posts/e41d3209/","excerpt":"核心类http.Server 提供服务处理客户端的请求http.ServerResponse 服务端针对客户端的请求做出响应http.IncomingMessage 获取服务端/客户端返回的相关信息http.ClientRequest 客户端向服务端发起请求 http.Server类提供服务，处理客户端的请求 createServer(requestListener) 123456789101112131415161718192021222324252627282930313233/** * @param requestListener(request,response) &lt;Function&gt; 当接收到客户端的请求时候进行的处理 * * * * * @param request http.IncomingMessage对象 指客户端的请求 * * * * * @param response http.serverResponse对象 指服务端的响应 * @return HTTP Server类 * * 继承自 net.server 类且具有以下额外事件方法属性 * @event clientError 客户端触发一个Error事件,该事件监听器负责销毁底层socket * * * * callback(err,socket) * * * * @param err 错误对象 * * * * @param socket net.socket对象 触发此事件将不会有(req,res),所以发送任何http响应,应写入socket对象 * @event close 当http服务关闭触发 * @event connect 当客户端发送HTPP CONNECT请求时候触发,HTTP method为connect,该事件未被监听则客户端会关闭连接 * @event connection 客户端和服务端建立连接时触发 callabck(socket) * * * * @param socket 服务端监听客户端的socket对象 * @event request callback(req,res) 每接收到一个请求时触发，多个request可能对应的是一个 connection(keep-alive), 参数值同requestListener * @event upgrade callback(req,socket,head) 每当客户端发送http upgrade请求时触发，该事件未被监听则客户端会关闭连接 * * @method close 停止服务端接收新的连接 * @method listen([port],[hostname],[backlog],[callback]) * * * * * @param port &lt;number&gt; 端口 默认随机分配 * * * * * @param hostname &lt;string&gt; 主机名域名 * * * * * @param backlog &lt;number&gt; 等待连接的队列最大长度 默认511 * * * * * @param callback &lt;function&gt; 回调 * @method listen(path,[callback]) 启动一个unix socket服务 * @method listen(handle,[callback]) * @method setTimeout([msecs=120000],[callback]) 设置socket超时时间,发生超时触发服务器对象的 'timeout' 事件,并传入 socket 作为一个参数 * * @property listening [boolean] 服务是否在监听连接 * @property maxHeaderCount 限制请求头的最大数量 默认2000 0表示无限制 * @property timeout 设置获取连接超时时间 * @property keepAliveTimeout 服务器完成最后的响应需要等待额外数据的时间,保持活跃的毫秒数,之后才销毁socket */","text":"核心类http.Server 提供服务处理客户端的请求http.ServerResponse 服务端针对客户端的请求做出响应http.IncomingMessage 获取服务端/客户端返回的相关信息http.ClientRequest 客户端向服务端发起请求 http.Server类提供服务，处理客户端的请求 createServer(requestListener) 123456789101112131415161718192021222324252627282930313233/** * @param requestListener(request,response) &lt;Function&gt; 当接收到客户端的请求时候进行的处理 * * * * * @param request http.IncomingMessage对象 指客户端的请求 * * * * * @param response http.serverResponse对象 指服务端的响应 * @return HTTP Server类 * * 继承自 net.server 类且具有以下额外事件方法属性 * @event clientError 客户端触发一个Error事件,该事件监听器负责销毁底层socket * * * * callback(err,socket) * * * * @param err 错误对象 * * * * @param socket net.socket对象 触发此事件将不会有(req,res),所以发送任何http响应,应写入socket对象 * @event close 当http服务关闭触发 * @event connect 当客户端发送HTPP CONNECT请求时候触发,HTTP method为connect,该事件未被监听则客户端会关闭连接 * @event connection 客户端和服务端建立连接时触发 callabck(socket) * * * * @param socket 服务端监听客户端的socket对象 * @event request callback(req,res) 每接收到一个请求时触发，多个request可能对应的是一个 connection(keep-alive), 参数值同requestListener * @event upgrade callback(req,socket,head) 每当客户端发送http upgrade请求时触发，该事件未被监听则客户端会关闭连接 * * @method close 停止服务端接收新的连接 * @method listen([port],[hostname],[backlog],[callback]) * * * * * @param port &lt;number&gt; 端口 默认随机分配 * * * * * @param hostname &lt;string&gt; 主机名域名 * * * * * @param backlog &lt;number&gt; 等待连接的队列最大长度 默认511 * * * * * @param callback &lt;function&gt; 回调 * @method listen(path,[callback]) 启动一个unix socket服务 * @method listen(handle,[callback]) * @method setTimeout([msecs=120000],[callback]) 设置socket超时时间,发生超时触发服务器对象的 'timeout' 事件,并传入 socket 作为一个参数 * * @property listening [boolean] 服务是否在监听连接 * @property maxHeaderCount 限制请求头的最大数量 默认2000 0表示无限制 * @property timeout 设置获取连接超时时间 * @property keepAliveTimeout 服务器完成最后的响应需要等待额外数据的时间,保持活跃的毫秒数,之后才销毁socket */ http.ServerResponse类服务端针对客户端的请求做出响应 serverResponse 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 服务端响应流 可写流 * * 事件方法属性 * @event close end方法调用之前被终止触发 * @event finish 当响应已被发送时触发（不意味着客户端已接收到任何东西）,此后响应对象不再触发任何事件 * * @method addTrailers(headers) 添加http尾部响应头到响应 * @method end([data],[encoding],[callback]) 通知服务器所有响应头和响应主体都被发送 * @method setHeader(name,value) 为一个隐式的响应头设置值 改+增 * * * * * Tips: 如果该响应头已存在,则值会被覆盖,如果要发送多个名称相同的响应头,则使用字符串数组 * * * * * Tips: write方法第一次被调用随即发送响应头，而writeHeader调用时即发送响应头 * @method getHeader(name) @return [string] 读取一个已入队列但尚未发送到客户端的响应头,名称不区分大小写 * @method getHeaderNames() @return [array] 返回包含当前响应唯一名称的http头信息名称数组,名称均小写 * @method getHeaders @return [object] 返回当前响应头信息 查 * @method hasHeader(name) @return [boolean] 判断是否含有一个已入队列但尚未发送到客户端的响应头 * @method removeHeader(name) 从隐式发送的队列中移除一个响应头 删 * @method writeHeader(statusCode,[statusMessage],[headers]) 优先级高于setHeader 并且在write()和end()之前调用，否则会切换到隐式响应头 * * * * * @param statusCode [number] 状态码 * * * * * @param statusMessage [string] 状态描述 * * * * * @param headers [object] 服务端响应头 * * * * * * * * * headers = &#123; * * * * * * * * * content-type: 指定内容类型, * * * * * * * * * location: 用于将客户端重定向到另一个url地址, * * * * * * * * * content-disposition: 用于指定一个被下载的文件名, * * * * * * * * * content-length: 用于指定服务端响应内容的字节数, * * * * * * * * * set-cookie: 用于在客户端创建一个cookie * * * * * * * * * content-encoding: 服务器端相应内容的编码方式 * * * * * * * * * Cache-Control:用于开启缓存机制 * * * * * * * * * Expires: 用于指定缓存过期时间 * * * * * * * * * Etag: 用于指定当服务端响应内容没有变化时不重新下载数据 * * * * * * * * * &#125; * @method write(chunk,[encoding],[callback]) 发送一块响应主体 * * * * * @param chunk [string|buffer] * * * * * @param encoding [string] 默认‘utf8’ * * * * * @param callback [function] * * * * * @return [boolean] 全部数据进入内核缓存区-true 全部或者部分数据依然在内存排队-false * * @property finished [boolean] 表示响应是否已经完成 执行end()之后会变成true * @property headersSent 返回一个布尔值(只读),如果响应头已被发送则为 true,否则为 false * @property sendDate 默认为 true,如果false响应头里没有日期响应头,否则日期响应头会被自动生成并发送 * @property statusCode 当使用隐式的响应头时（没有显式地调用 response.writeHead()）,该属性控制响应头刷新时将被发送到客户端的状态码。 * @property statusMessage 当使用隐式的响应头时,该属性控制响应头刷新时将被发送到客户端的状态信息。 */ http.IncomingMessage类获取客户端请求的相关信息 serverRequset获取服务端返回的相关信息 clientResponse123456789101112131415161718192021222324/** * 可读流 * IncomingMessage对象由 http.Server或http.ClientRequest创建， * 作为第一个参数分别递给 'request' 和 'response' 事件，它可以用来访问响应状态、消息头、以及数据 * * 事件方法属性 * @event aborted * @event close * @event end * @event data * * @method destory([error]) 调用接收到 IncomingMessage的socket上的destroy()方法 * @method setTimeout(msecs, callback) * * @property headers 请求头或响应头的对象 头信息的名称与值的键值对 头信息的名称为小写 * @property httpVersion 返回客户端发送http的版本 （1.0、1.1） * @property method @return [string] 该属性只读，表示请求的方法 server only * @property rawHeaders @return [array] 接收到的原始的请求头或响应头列表，键和值在同一个列表中，偶数位的是键，奇数位的是对应的值 * @property url 返回请求的 URL 字符串,仅包含实际 HTTP 请求中的 URL,参数字符串 * @property trailers 返回 Trailer 请求头或响应头对象 * @property statusMessage HTTP响应状态消息 client only * @property statusCode HTTP响应状态码 client only * @property socket */ 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const http = require('http');const url = require('url');const querystring = require('querystring');let server = http.createServer((serverRequest, serverResponse) =&gt; &#123; if (serverRequest.url !== '/favicon.ico') &#123; const file = fs.createWriteStream('./res.log'); let strData = ''; file.write(`客户端请求方法：$&#123;serverRequest.method&#125;\\r\\n`); file.write(`客户端请求url的参数字符串：$&#123;serverRequest.url&#125;\\r\\n`); file.write(`客户端请求头对象：$&#123;JSON.stringify(serverRequest.headers)&#125;\\r\\n`); file.write(`客户端请求http版本：$&#123;serverRequest.httpVersion&#125;\\r\\n`); // get请求 // const urlObj = url.parase(serverRequest.url) // const query = urlObj.query // const queryObj = querystring.parase(query) // res.end(JSON.stringify(queryObj)) // post请求 serverRequest.on('data', data =&gt; &#123; strData += data; &#125;); serverRequest.on('end', () =&gt; &#123; let bodyStr; if (typeof(strData) !== 'string') &#123; objData = querystring.parse(strData); file.end(`服务端接收到的表单数据:my name is $&#123;objData.myname&#125; and my age is $&#123;objData.myage&#125;\\r\\n`); bodyStr = `服务端接收到的表单数据:my name is $&#123;objData.myname&#125; and my age is $&#123;objData.myage&#125;\\r\\n`; &#125; else &#123; bodyStr = `服务端接收到的数据:$&#123;strData&#125;`; &#125; // 响应体 可用路由处理 serverResponse.setTimeout(10 * 1000); serverResponse.writeHead(200, &#123; 'content-type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '127.0.0.1', 'Trailer': 'content-MD5' &#125;); if (serverResponse.headersSent) &#123; console.log('响应头已发送'); &#125; else &#123; console.log('响应头未发送'); &#125; serverResponse.addTrailers(&#123; 'content-MD5': 'xxxxxxx' &#125;); serverResponse.write(` &lt;html&gt; &lt;head&gt;&lt;title&gt;node应用程序&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;node webserver start&lt;/h1&gt;&lt;h2&gt;$&#123;bodyStr&#125;&lt;/h2&gt;&lt;/body&gt; &lt;html&gt; `); serverResponse.on('timeout', () =&gt; &#123; console.log('响应超时'); &#125;); serverResponse.on('close', () =&gt; &#123; console.log('end方法未被调用之前，连接被中断'); &#125;); serverResponse.end(); console.log(`客户端请求数据全部接收完毕`); &#125;); &#125;&#125;).listen(8888, '127.0.0.1', () =&gt; &#123; console.log(`服务端开始监听 `); // setTimeout(() =&gt; &#123; server.close(); &#125;, 10000)&#125;);server.on('connnection', () =&gt; &#123; console.log('客户端连接已建立');&#125;);server.setTimeout(60 * 1000, socket =&gt; &#123; console.log(`服务器超时，socket对象：$&#123;socket&#125;`);&#125;);server.on('close', () =&gt; &#123; console.log('服务被关闭');&#125;);server.on('error', err =&gt; &#123; console.log(`发生错误代码：$&#123;err.code &#125;`);&#125;); http.ClientRequest向服务端发起请求,可写流 client http.request(options,[callback]) 123456789101112131415161718192021222324252627282930313233343536/** * * @param options &lt;Object|String|URL&gt; 指定请求的目标地址以及相关配置 * * * * * options &lt;Object&gt; = &#123; protocol,host,hostname,family,port,localAdrress,socketPath,method,path,headers,auth,agent,timeout,createConnection &#125; * @param callback(response) &gt; @param clinetResponse http.IncomingMessage对象,利用该对象读取响应流数据 * @return 返回ClientRequest类实例,代表一个客户端请求,可写流 * * 事件方法属性 * @event abort 首次调用abort(),请求被客户端中止触发,客户端主动中断 * @event aborted 请求被服务器中止,且网络socket已被关闭,服务端主动中断 * @event connect 服务器响应connect请求时触发 * * * * callback(req,socket,head) * * * * @param req &lt;http.IncomingMessage&gt; * * * * @param socket &lt;net.socket&gt; * * * * @param head &lt;buffer&gt; * @event continue 当收到服务端的响应 100 Continue 时触发 * @event error 在向目标网站请求数据过程中发生错误 * @event response 当请求的响应被接收到时触发，只触发一次 * @event socket 建立连接分配端口时候触发 callback(socket) * * * * @param socket 用于分配的socket端口对象 * @event upgrade 服务器响应upgrade请求时触发 请求首部里声明 'Connection': 'Upgrade'要求服务端将当前连接升级到新的协议 * * * * callback(req,socket,head) * * * * @param req &lt;http.IncomingMessage&gt; * * * * @param socket &lt;net.socket&gt; * * * * @param head &lt;buffer&gt; * * @method abort() 标记请求中止，剩余相应数据被丢弃且销毁socket * @method end([[data],[encoding]],[callback]) 结束本次发送请求 * @method flushHeaders() 刷新请求头 * @method setNoDelay([noDelay]) 见socket.setNoDelay() 默认true * @method setSocketKeepAlive([enable],[initialDelay]) 见socket.setKeepAlive() 默认flase * @method setTimeout(timeout,[callback]) 见socket.setTimeout() * @method write(chunk,[encoding],[callback])发送请求主题的一个数据块 * * @property aborted 如果请求被终止 打印被中止的时间距1970 00:00:00毫秒数 */ 代码示例123456789101112131415161718192021222324252627282930313233343536373839const http = require('http');const options = &#123; hostname: '127.0.0.1', port: 8888, path: '/', method: 'POST'&#125;;// 发送给服务端的数据const postBody = &#123; name: 'jacky'&#125;;const client = http.request(options, (clientResponse) =&gt; &#123; console.log(`状态码:$&#123;clientResponse.statusCode&#125;\\r\\n`); console.log(`响应头:$&#123;JSON.stringify(clientResponse.headers)&#125;\\r\\n`); clientResponse.setEncoding('utf8'); clientResponse.on('data', chunk =&gt; &#123; console.log(`客户端接收到的内容:$&#123;chunk&#125;\\r\\n`); &#125;); clientResponse.on('end', () =&gt; &#123; console.log(`trailers头信息:$&#123;JSON.stringify(clientResponse.trailers)&#125;`); &#125;);&#125;);client.on('error', err =&gt; &#123; console.log(`请求发生错误$&#123;err&#125;`);&#125;);client.on('socket', socket =&gt; &#123; socket.setTimeout(10000); socket.on('timeout', () =&gt; &#123; console.log('socket请求超时'); client.abort(); &#125;);&#125;);client.setTimeout(1000, () =&gt; &#123; console.log('socket请求超时'); client.abort();&#125;);client.write(querystring.stringify(postBody));client.end(); //每次请求结束必须调用end方法 原创内容，欢迎交流转载请注明出处","categories":[{"name":"node","slug":"node","permalink":"https://joacycode.github.io/categories/node/"}],"tags":[{"name":"http.Server","slug":"http-Server","permalink":"https://joacycode.github.io/tags/http-Server/"},{"name":"http.ServerResponse","slug":"http-ServerResponse","permalink":"https://joacycode.github.io/tags/http-ServerResponse/"},{"name":"http.IncomingMessage","slug":"http-IncomingMessage","permalink":"https://joacycode.github.io/tags/http-IncomingMessage/"},{"name":"http.ClientRequest","slug":"http-ClientRequest","permalink":"https://joacycode.github.io/tags/http-ClientRequest/"}],"keywords":[{"name":"node","slug":"node","permalink":"https://joacycode.github.io/categories/node/"}]},{"title":"node笔记整理之fs和path","slug":"2018-node-fs-path","date":"2018-03-06T14:27:20.000Z","updated":"2021-09-26T02:00:01.906Z","comments":true,"path":"posts/7b756efa/","link":"","permalink":"https://joacycode.github.io/posts/7b756efa/","excerpt":"FS模块打开文件fs.open(path, flags[, mode], callback) 12345678910111213141516171819202122232425262728293031// flags: 文件打开模式，读取为'r'，写入为'w'，追加为'a'// 读取fs.open('./readfile.txt', 'r', (err, fd) =&gt; &#123; if (err) &#123; console.log('发生错误: ' + err); &#125; else &#123; let buff = Buffer.allocUnsafe(255); // fs.read() @params(文件描述，指定读入的缓存，写入缓存开始位置，写入长度，读取文件开始位置,callback) // callback() @params(错误对象，实际长度，被读取缓存的对象) fs.read(fd, buff, 0, 28, 0, (err, bytesRead, buffer) =&gt; &#123; let newBuff = buffer.slice(0, bytesRead).toString(); console.log(bytesRead, newBuff); &#125;); &#125;&#125;);// 写入fs.open('./writefile.txt', 'a', (err, fd) =&gt; &#123; if (err) &#123; console.log('发生错误: ' + err); &#125; else &#123; let buff = Buffer.from('打开后写入：nodeJs博大精深~\\r\\n'); // fs.write() @params(文件描述，指定读出的缓存，读取缓存开始位置，读取长度|null默认长度，写入文件开始位置|null上次位置,callback) // callback() @params(错误对象，实际长度，被读取缓存的对象) fs.write(fd, buff, 0, null, null, (err, written, buffer) =&gt; &#123; if (err) console.log('写文件失败'); console.log('写文件成功', written, buffer); fs.fsync(fd, err =&gt; &#123; if (err) console.log('fsync错误：' + err) &#125;); fs.close(fd, err =&gt; &#123; if (err) console.log('close错误：' + err) &#125;); &#125;); &#125;&#125;);","text":"FS模块打开文件fs.open(path, flags[, mode], callback) 12345678910111213141516171819202122232425262728293031// flags: 文件打开模式，读取为'r'，写入为'w'，追加为'a'// 读取fs.open('./readfile.txt', 'r', (err, fd) =&gt; &#123; if (err) &#123; console.log('发生错误: ' + err); &#125; else &#123; let buff = Buffer.allocUnsafe(255); // fs.read() @params(文件描述，指定读入的缓存，写入缓存开始位置，写入长度，读取文件开始位置,callback) // callback() @params(错误对象，实际长度，被读取缓存的对象) fs.read(fd, buff, 0, 28, 0, (err, bytesRead, buffer) =&gt; &#123; let newBuff = buffer.slice(0, bytesRead).toString(); console.log(bytesRead, newBuff); &#125;); &#125;&#125;);// 写入fs.open('./writefile.txt', 'a', (err, fd) =&gt; &#123; if (err) &#123; console.log('发生错误: ' + err); &#125; else &#123; let buff = Buffer.from('打开后写入：nodeJs博大精深~\\r\\n'); // fs.write() @params(文件描述，指定读出的缓存，读取缓存开始位置，读取长度|null默认长度，写入文件开始位置|null上次位置,callback) // callback() @params(错误对象，实际长度，被读取缓存的对象) fs.write(fd, buff, 0, null, null, (err, written, buffer) =&gt; &#123; if (err) console.log('写文件失败'); console.log('写文件成功', written, buffer); fs.fsync(fd, err =&gt; &#123; if (err) console.log('fsync错误：' + err) &#125;); fs.close(fd, err =&gt; &#123; if (err) console.log('close错误：' + err) &#125;); &#125;); &#125;&#125;); 读写文件1234567891011121314151617181920212223const buff = Buffer.from('nodejs博大精深');const addStr = Buffer.from('\\r\\n这是追加的内容@#$%');let options = &#123; flag: 'a+', encoding: 'utf8', mode: '0666'&#125;;fs.readFile('./readfile.txt', 'utf8', (err, data) =&gt; &#123; if (err) &#123; console.log('发生错误: ' + err); &#125; else &#123; console.log('开始读取内容: ' + data); &#125;&#125;);fs.writeFile('./writefile.txt', addStr, options, function(err) &#123; if (err) &#123; console.log('发生错误: ' + err); &#125; else &#123; console.log('写文件成功'); &#125;&#125;); 文件流方式读文件fs.createReadStream(path,[options])123456789101112131415161718192021222324252627282930313233343536373839404142/* * * fs.createReadStream(path,[options]) 返回ReadStream对象 * @params path 指定需要读取完整路径以及文件名 * @params options [flags,encoding,autoclose,start,end] * * ReadStream对象 * @event readable 当可以从流中读取数据时触发 * @event open 当文件被打开时触发 * @event data 当读取到新的数据时触发 参数为存放已读取到的数据缓存区对象或者字符串 * @event end 当读取完所有数据时触发 此时data事件不再被触发 * @event error 当读取数据过程中出现错误时触发 * @event close 当用于读取流数据的对象被关闭时触发 * @method read 用于读取数据 * @method setEncoding 指定用何种编码读取数据 * @method pause 通知对象停止data事件触发 * @method resume 通知对象恢复触发data事件 * @method pipe 设置数据通道，取出所有流数据传输给通道另一端对象 * @method unpipe 取消pipe方法设置的通道 * @method unshift 取消解析器绑定 流数据采用其他方式解析 */let rfile = fs.createReadStream('./writefile.txt', &#123; start: 0, end: 20 &#125;);rfile.pause();setTimeout(() =&gt; &#123; rfile.resume();&#125;, 1000);rfile.resume();rfile.on('open', fd =&gt; &#123; console.log('开始读取文件');&#125;);rfile.on('data', data =&gt; &#123; console.log('读取到数据：' + data);&#125;);rfile.on('end', () =&gt; &#123; console.log('文件全部读取完毕');&#125;);rfile.on('close', () =&gt; &#123; console.log('文件被关闭');&#125;);rfile.on('error', err =&gt; &#123; console.log('读取文件失败' + err);&#125;); 文件流方式写文件fs.createWriteStream(path,[options])123456789101112131415161718192021222324/* * * fs.createWriteStream(path,[options]) 返回WriteStream对象 * @params path 指定需要写入的完整路径以及文件名 * @params options [flags,encoding,start] * * WriteStream对象 * @event drain 操作系统缓存区中的数据已全部输出到目标对象中，可以继续向前者写入数据 * @event finish end方法被调用且数据被全部写入操作系统缓存区时候触发 * @event pipe 读取数据的对象的pipe方法被触发时候 * @event unpipe 读取数据的对象的unpipe方法被触发时候 * @event error 当读取数据过程中发生错误 * @method write(chunk,[encoding],[callback]) 用于写入数据 * * * * * @params chunk 要写入的的数据 Buffer或String * * * * * @params encoding 指定编码写入 * * * * * @params callback 写入完毕回调 无参数 * * * * * @return 表示操作系统缓存是否未满 还可以写入数据 * @method end 当没有数据再被写入流中调用 */let writable = fs.createWriteStream('./writefile.txt', &#123; flags: 'a', encoding: 'utf8' &#125;);let flag = writable.write('create node stream txt\\r\\n', 'utf8', () =&gt; &#123; console.log('write写入成功');&#125;);console.log(flag); //true || false 图片文件读写12345678910111213fs.readFile('./sample.png', 'base64', (err, data) =&gt; &#123; if (err) &#123; console.log('读文件发生错误: ' + err); &#125; else &#123; fs.writeFile('./copy.jpg', data.toString(), 'base64', (err) =&gt; &#123; if (err) &#123; console.log('写文件发生错误: ' + err); &#125; else &#123; console.log('写文件成功'); &#125; &#125;); &#125;&#125;); 创建并读取目录123456789101112/* * fs.mkdir(path,[mode],callback) callback @params(错误对象) * fs.readdir(path,callback) callback @params(错误对象, 所有文件名) */fs.mkdir('./test/childfile', err =&gt; &#123; if (err) console.log(err); console.log('创建目录成功');&#125;);fs.readdir('./', (err, files) =&gt; &#123; if (err) console.log(err); console.log(files);&#125;); 查看文件目录信息1234567891011121314151617/* * fs.stat(path,callback) &amp; fs.lstat(path,callback) * callback @params(错误对象, fs.Stats对象) * fs.Stats对象 * @methods isFile() 是否是文件 * @methods isDirectory() 是否是目录 * @methods isSymbolicLink() 是否是符号链接 * @property mode 数字形式权限表示 * @property nlink 硬链接数量 * @property size 文件大小 * @property atime 访问时间 * @property mtime 修改时间 * @property ctime 创建时间 */fs.stat('./test', (err, stats) =&gt; &#123; if (!err) console.log(stats);&#125;); 检查文件目录是否存在123fs.exists('./message', exists =&gt; &#123; console.log(exists);&#125;); 获取文件目录绝对路径1234567891011/* * fs.realpath(path,[cache],callback) * @params path 要查看文件目录的完整路径 * @params cache 预先指定的路径 * callback @params err错误对象 * callback @params resolvePath文件或者目录的绝对路径 */fs.realpath('./test/childfile', (err, resolvePath) =&gt; &#123; if (err) throw err; console.log(resolvePath);&#125;); 修改文件目录访问修改时间1234567891011/* * fs.utimes(path,atime,mtime,callback) * fs.futimes(fd,atime,mtime,callback) * @params atime 指定修改后的访问时间 * @params mtime 指定修改后的修改时间 * @params fd 使用open方法打开后返回的文件描述 */fs.utimes('./test/childfile', new Date(), new Date(), err =&gt; &#123; if (err) throw err; console.log('修改文件时间成功~');&#125;); 修改文件目录的访问权限12345678910111213/* * fs.chmod(path,mode,callback) * fs.chmod(fd,mode,callback) * @params mode 数字形式的权限表示法 * @params fd 使用open方法打开后返回的文件描述 * callback @params err 错误对象 * 0+ r=4 w=2 x=1 * user group other */fs.chmod('./test', 0740, err =&gt; &#123; if (err) throw err; console.log('文件权限修改成功!');&#125;); 移动文件、目录12345678/* * fs.rename(oldpath,newpath,callback) * callback @params err 错误对象 */fs.rename('./readfile.txt', './test/childfile/newfile.txt', err =&gt; &#123; if (err) throw new Error('移动失败' + err); console.log('移动文件成功');&#125;); 截断文件、修改文件大小123456789101112131415/* * fs.truncate(filename,len,callback) * fs.truncate(fd,len,callback) * @params filename 被截断的完整路径文件名 * @params len 截断后的文件尺寸（字节） * @params fd open方法打开返回的文件描述 * callback @params err 错误对象 */fs.truncate('./truncate.txt', 30, err =&gt; &#123; if (err) throw err; fs.stat('./truncate.txt', (err, stats) =&gt; &#123; if (err) throw err; console.log(stats.size); &#125;);&#125;); 删除空目录1234567/* * fs.rmdir(path,callback) */fs.rmdir('./rmdir', err =&gt; &#123; if (err) throw err; console.log('删除目录成功');&#125;); 监视文件、目录 取消监视监视 fs.watchFile(filename,[options],listener)监视 fs.watch(filename,[options],callback)取消监视 fs.unwatchFile(filename,[listener]) 12345678910111213141516171819202122232425262728293031/* * fs.watchFile(filename,[options],listener) * fs.unwatchFile(filename,[listener]) * @params filename 监听文件的完整目录文件名 * @params listener 监听的文件发生改变执行的回调，同一文件可监听多个回调 * @params [listener] 取消监听的文件执行的某一回调 * options [Object] @property persistent 表明当文件正在被监视时，进程是否应该继续运行 * options [Object] @property interval 表示目标应该每隔多少毫秒被轮询 * listener @params curr 修改后的文件fs.Stats对象 * listener @params prev 修改前的文件fs.Stats对象 */fs.watchFile('./readfile.txt', (curr, prev) =&gt; &#123; if (Date.parse(prev.ctime) === 0) &#123; console.log('文件被创建~'); &#125; else if (Date.parse(curr.ctime) === 0) &#123; console.log('文件被删除~'); &#125; else if (Date.parse(curr.mtime) !== Date.parse(prev.mtime)) &#123; console.log('文件被修改'); &#125;&#125;);// 监听另一方法// fs.watch(filename,[options],callback)// callback(event,filename)// @params event = 'rename' 移动删除重命名 || 'change'内容改动// @params filename 指定目录中发生改动的文件完整路径以及文件名let watcher = fs.watch('./test/', (event, filename) =&gt; &#123; console.log(event, filename);&#125;);watcher.close(); //停止监听 创建删除文件[硬链接] 不同文件名指向同一文件123456789101112131415/* * fs.link(srcpath,distpath,callback) * fs.unlink(path,callback) * @params srcpath 创建硬链接源 * @params distpath 创建硬链接目标 * callback @params err 错误对象 */fs.link('./writefile.txt', './test/childfile/link2.txt', err =&gt; &#123; if (err) throw err; console.log('创建硬链接成功');&#125;);fs.unlink('./symlink', err =&gt; &#123; if (err) throw err; console.log('删除硬链接成功');&#125;); 创建查看[符号链接] 创建替身 打开符号链接自动指向源12345678910/* * fs.symlink(srcpath,distpath,[type],callback) * @params type 默认file [,dir]创建类型 * @params srcpath 创建符号链接源 * @params distpath 创建符号链接源 */fs.symlink('./test', './symlink', err =&gt; &#123; if (err) throw err; console.log('创建符号链接成功');&#125;); 读取符号链接中包含另一个文件的目录、文件名1234567891011121314/* * fs.readlink(path, callback) * @params path 符号链接路径以及文件名 * callback @params err 错误对象 * callback @params linkString [String] 另一个文件的目录、文件名 */fs.symlink('./srclink.txt', './symlink.txt', err =&gt; &#123; if (err) throw err; console.log('创建符号链接symlink.txt成功'); fs.readlink('./symlink.txt', (err, linkString) =&gt; &#123; if (err) throw err; console.log(linkString); &#125;);&#125;); Path模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * const path = require('path') * @property path.delimiter 提供平台特定的路径分隔符 win;posix: * @property path.posix * @property path.sep * @property path.win32 * * @method path.isabsolute(path) 判定 path 是否为一个绝对路径 * @method path.basename(path,[ext]) 返回path的最后一部分，ext为后缀 * @method path.dirname(path) 返回path的目录名 * @method path.extname(path) 返回path的拓展名 * * @method path.format(pathObject) 从对象返回路径字符串 * @method path.parse(path) 根据path返回pathObject对象 * * * * * pathObject = &#123;dir,root,base,name,ext&#125; * * * * * 优先级 dir &gt; root base &gt; name &amp; ext * * @method path.normalize(path) 规范化path 解析'..''.',路径分隔符去重 * @method path.join([...path]) 使用平台特定的分隔符把全部给定的 path片段连接到一起，并规范化生成的路径 * @method path.relative(fromPath,toPath) 返回从fromPath到toPath的相对路径 * @method path.resolve([...path]) 全部给定的path解析为一个绝对路径 */// /foo/bar/baz/asdflet path_normalize = path.normalize('/foo/bar//baz/asdf/quux/..');// /foo/bar/baz/asdflet path_join = path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// /bar/img/imgage.pnglet path_resolve = path.resolve('/foo', 'bar', '/bar/img', '../img/imgage.png');// ../../impl/bbblet path_relative = path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');// /data/orandea/test/aaalet path_dirname = path.dirname('/data/orandea/test/aaa/img.gif');// img.giflet path_basename = path.basename('/data/orandea/test/aaa/img.gif');// .giflet path_extname = path.extname('/data/orandea/test/aaa/img.gif');// &#123; // root: '/',// dir: '/data/orandea/test/aaa',// base: 'img.gif',// ext: '.gif',// name: 'img' // &#125;let path_parse = path.parse('/data/orandea/test/aaa/img.gif');// /data/orandea/test/aaa/img.giflet path_format = path.format(&#123; root: '/', dir: '/data/orandea/test/aaa', base: 'img.gif', ext: '.gif', name: 'img'&#125;); 原创内容，欢迎交流转载请注明出处","categories":[{"name":"node","slug":"node","permalink":"https://joacycode.github.io/categories/node/"}],"tags":[{"name":"fs","slug":"fs","permalink":"https://joacycode.github.io/tags/fs/"},{"name":"path","slug":"path","permalink":"https://joacycode.github.io/tags/path/"}],"keywords":[{"name":"node","slug":"node","permalink":"https://joacycode.github.io/categories/node/"}]},{"title":"js的this指向实践问题记录","slug":"20180206jsthis","date":"2018-02-06T17:00:54.000Z","updated":"2021-09-26T02:21:51.651Z","comments":true,"path":"posts/64d676f8/","link":"","permalink":"https://joacycode.github.io/posts/64d676f8/","excerpt":"遇到的this问题的翻车事故this对于当时刚接触js的人来说幽灵一般的存在，就是老司机也不免有大意翻车的时候，印象中很多前端面试的基础部分考察prototype和this是必不可少的。前几天改一个bug改出this的问题，大意翻车，虽然很快就解决了，但还是警醒下自己，温习梳理以免再出错。问题类似下面的代码块，对象外提取公共模块导入，对象内部方法和属性通过对象传参params的方式进入setTime方法执行业务逻辑。","text":"遇到的this问题的翻车事故this对于当时刚接触js的人来说幽灵一般的存在，就是老司机也不免有大意翻车的时候，印象中很多前端面试的基础部分考察prototype和this是必不可少的。前几天改一个bug改出this的问题，大意翻车，虽然很快就解决了，但还是警醒下自己，温习梳理以免再出错。问题类似下面的代码块，对象外提取公共模块导入，对象内部方法和属性通过对象传参params的方式进入setTime方法执行业务逻辑。1234567891011121314151617181920function setTime(params)&#123; setTimeout(function fn4() &#123; params.keyFn2(); &#125;,0)&#125;var obja=&#123; valname: 'xzhang', fn1()&#123; return this.valname + ' did fn1'; &#125;, fn2()&#123; return this.fn1()+' and did fn2'; &#125;, fn3()&#123; setTime(&#123; keyFn2: this.fn2 &#125;); &#125;&#125;obja.fn3();但是执行后报错，fn2方法是执行过后，但是里面却找不到fn1这个方法，看到这个bug一脸懵逼。老司机也会翻车好像说的就是我，当时就想当然的的认为(以下是错误思考过程)fn2通过this.fn2传参进入，this也会传进去，所以this.fn1的this理所应当的指向obja,所有的方法都会找到自己的对象宿主去执行（错误思考过程结束），还是因为懒，思想都不愿意往前多想一步。遇到问题总是要解决的。先思考后动手是我的习惯，这里报错很显然是this指向出现了问题，找到这个问题根源，也就不难发现根源在哪里、怎么去解决了。so…万年不变的console调式大法1234567891011121314151617181920212223function setTime(params)&#123; setTimeout(function fn4() &#123; console.log(this, 'fn3-fn4'); params.keyFn2(); &#125;,0)&#125;var obja=&#123; valname: 'xzhang', fn1()&#123; console.log('fn1',this); return this.valname + ' did fn1'; &#125;, fn2()&#123; console.log('fn2',this); return this.fn1()+' and did fn2'; &#125;, fn3()&#123; setTime(&#123; keyFn2: this.fn2 &#125;); &#125;&#125;obja.fn3();结果如下：果不其然fn2中的this指向出现了问题，所以找不到fn1方法很正常。错误的this指向了一个对象，既不是windows也不是obja，而是{keyFn2: f}，看着好眼熟，嗯？这个对象不就是我们setTime传进去的对象参数params么?再看看fn4里的调用方法params.keyFn2(),所以一切都很明了了：setTime里的keyFn2方法能够通过this.fn2传参进去，方法能够得到执行，但是fn2方法里面还有this，这个this的指向就有问题了，它指向的是调用这个方法的params也就是{keyFn2: f}，这个对象里根本没有fn1方法！进一步fn1就算得到执行，方法里面的依然有this的问题，所以也得进行手动指向。如果想得到正确的结果必须明确this的指向。1234567891011121314151617181920212223function setTime(params)&#123; setTimeout(function fn4() &#123; console.log(params.keyFn2(params.self)); &#125;,0)&#125;var obja=&#123; valname: 'xzhang', fn1(s)&#123; const self = s? s : this; return self.valname + ' did fn1'; &#125;, fn2(s)&#123; const self = s? s : this; return self.fn1(s)+' and did fn2'; &#125;, fn3()&#123; setTime(&#123; keyFn2: this.fn2, self: this &#125;); &#125;&#125;obja.fn3();大功告成，到这里bug就算修复完毕了，但是思考一个问题，我们工作就是为了码代码，修复bug的么？ 这个是不是最佳的处理方式呢？ 上面的代码没有提取公共模块之前是下面这么写的，一点问题都没有，this指向正常，除了通过_this纠正了es5的指向，其他并不需要操心。但是需要使用额外的外界方法，并且方法中涉及this指向的问题就需要小心了。12345678910111213141516171819var objb=&#123; valname: 'xzhang', fn1()&#123; console.log('fn1',this); return this.valname + ' did fn1'; &#125;, fn2()&#123; console.log('fn2',this); return this.fn1()+' and did fn2'; &#125;, fn3()&#123; const _this = this; setTimeout(function fn4() &#123; console.log(\"fn3\", this, _this); console.log(_this.fn2()); &#125;,0) &#125;&#125;objb.fn3(); this指向总结老司机就不用往下看了，自己写出来也算是一种加深印象，就像小学时候写错一个字拿两杆笔写罚抄一百遍一样，为了不再犯错。*注：以下都为Browser环境 普通function里的this此时this指向全局windows,凡是挂载到windows上的变量方法此时都可以通过this调用。箭头函数也是如此。1234567var glb = 'windows';function testThis()&#123; console.log(this,this.glb);&#125;const arrowTestThis = ()=&gt;&#123; console.log(this,this.glb);&#125;不管函数嵌套多少层，this返回的都是windows new调用function里的this此时的this指向new出来的实例。1234567891011function newfun(params)&#123; if(typeof new.target == 'undefined') &#123; throw new Error('constructor must be called with new'); &#125; console.log('newfun里的this指向：',this); this.name = params.name; this.takebus = function()&#123; return this.name + ' takes bus'; &#125;&#125;var newObj = new newfun(&#123;name:'xzhang'&#125;);可以看到打印出来的this指向了new出来的实例，这里的this就暂时可以想象成newObj。 prototype里的thisConstructor的prototype属性上挂载的属性和方法都可以被实例所共享继承使用，避免了每次生成实例都需要累计占用内存的情况。Constructor里的this和prototype的挂载方法里的this在Constructor实例化后都将指向当前的实例对象，所以挂载在Constructor里的this上的方法属性以及挂载在prototype上的属性和方法，在Constructor里和prototype上挂载的方法里都是可以通过this调用（实例都可以访问的到）。123456789function Construc(name)&#123; this.name = name;&#125;Construc.prototype.age = '秘密';Construc.prototype.introduction = function()&#123; console.log('prototype里的this:',this); console.log('prototype:', Construc.prototype); console.log(this.name + ' age is ' + this.age);&#125;在prototype里打印当前的this以及Construc.prototype。prototype1里的this指向实例，例如construc。Construc.prototype为当前的prototype对象，里面包含constructorConstruc。 上面的代码块可以理解为下面的这种，只是帮助理解。1234567function Construc(name)&#123; this.name = name; this.age = '秘密'; this.introduction = function()&#123; console.log(this.name + ' age is ' + this.age); &#125;&#125;prototype上的属性方法完全被’代理’到了当前它的Constructor上，它的所有属性和方法都是Constructor的属性和方法，Construc里的this指向实例，Construc.prototype里的this自然也指向实例。 Object里的this这里的Object指的是字面量的，此时对象字面量里的this指向windows（对象属性中调用this）或者此object（对象方法函数中调用this）本身。12345678var testOBJ =&#123; name:'xzhang', age:20, testThis: this, dosome:function()&#123; console.log(this); &#125;&#125; event里的this此时的this指向事件绑定的dom节点，但是可以通过bind改变this指向。1234567&lt;div id=\"Objecthis\"&gt;...&lt;/div&gt;&lt;script&gt;var _dom = document.getElementById('Objecthis');_dom.addEventListener('click',function(e)&#123; console.log(this); // &lt;div id=\"Objecthis\"&gt;...&lt;/div&gt;&#125;); &lt;/script&gt; html里的this此时this指向dom本身1&lt;h5 id=\"html里的this\" onclick=\"console.log(this,typeof this)\"&gt;&lt;a href=\"#html里的this\" class=\"headerlink\" title=\"html里的this\"&gt;&lt;/a&gt;html里的this&lt;/h5&gt;我们在html里添加一个点击事件，并在点击事件中打印出this，此时我么可以看到console打印台里出现的是这个dom本身，注意这里this打印出来的不是字符串，而是一个dom对象。 如果把这点击事件提取出来封装成一个方法，点击事件时候调用这个方法，那么此时的this指向的是…windows,因为很显然上面提到了普通调用function的时候this都会指向全局1234&lt;h5 id=\"html里的this\" onclick=\"dosomething();\"&gt;&lt;a href=\"#html里的this\" class=\"headerlink\" title=\"html里的this\"&gt;&lt;/a&gt;html里的this&lt;/h5&gt;&lt;script&gt;function doSomething()&#123;console.log(this);&#125; //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;&lt;/script&gt; 原创内容，欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"this","slug":"this","permalink":"https://joacycode.github.io/tags/this/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"mac转windows入职舒适体验手册","slug":"20180125windows","date":"2018-01-25T19:59:50.000Z","updated":"2021-09-26T02:00:01.906Z","comments":true,"path":"posts/a055a843/","link":"","permalink":"https://joacycode.github.io/posts/a055a843/","excerpt":"“这辈子不可能windows的，不可能用windows的，体验太差了”，这是我用三年的mac之后感受到的，appple对于软硬件结合使用的用户体验真的是做到了极致，几近完美的retina和字体体验，三年几乎没有关过机的情况下没有任何卡顿。我从A出来之后到了J，这边强制性的配置了台式机windows7系统，当时我是拒绝的，个人电脑也没有很好的办法加到公司的网络，当时真的是硬着头皮从mac转windows的，果然一开机，这个开机速度，渣渣的屏幕和windows的默认字体，没有了习惯的Spotlight，加上J公司相对较差较慢的网络环境，强大到github,各种云，各种音乐视频网站都上不去的网络限制，真是感觉自己会因为一台设备和开发环境离职的感觉。但是，我要说但是，自己不可能这么幼稚的，一个人强大的表现是跳出自己舒适圈，去适应和挑战一些东西。随手查了资料，发现自己可以打造一个相对于舒适的设备环境体验,不用mac又如何？so…","text":"“这辈子不可能windows的，不可能用windows的，体验太差了”，这是我用三年的mac之后感受到的，appple对于软硬件结合使用的用户体验真的是做到了极致，几近完美的retina和字体体验，三年几乎没有关过机的情况下没有任何卡顿。我从A出来之后到了J，这边强制性的配置了台式机windows7系统，当时我是拒绝的，个人电脑也没有很好的办法加到公司的网络，当时真的是硬着头皮从mac转windows的，果然一开机，这个开机速度，渣渣的屏幕和windows的默认字体，没有了习惯的Spotlight，加上J公司相对较差较慢的网络环境，强大到github,各种云，各种音乐视频网站都上不去的网络限制，真是感觉自己会因为一台设备和开发环境离职的感觉。但是，我要说但是，自己不可能这么幼稚的，一个人强大的表现是跳出自己舒适圈，去适应和挑战一些东西。随手查了资料，发现自己可以打造一个相对于舒适的设备环境体验,不用mac又如何？so… 一个机械键盘原来用mac本的时候就用mac自带的键盘，没觉得有哪里不对。现在用完机械键盘之后发现非机械键盘还叫键盘？就像用完retina之后就再也回不去了，显示器非4k以上还能入手？第一件让自己舒适的事情就是入手一个机械键盘去减少无法更换屏幕带来的暴击，品牌自选。 一个舒适的椅子凡是加上人工学这几个字的椅子可真贵，但是人类进化到现在没有进化久坐的基因和身体构造，你的腰你的背你的颈椎你的臀部都会因为久坐变得各种不舒服，写到这我先活动的颈椎去了。一把舒适的座椅可以善待你的身体，品牌自选，最好带有可以调节的腰枕和头枕，午休可以后仰120。最好可以配一个升降台，每天交叉站立办公一会，这才是王道。 双屏或者三屏开发这个都懂得，无需解释。 以上只能让你舒适的做一个文员，喝着咖啡，坐在舒适的座椅上享受的敲敲文字。 以下针对开发同学，比如我。 Listary这个类似于mac的Spotlight，双击ctrl，即可以查询app，documents,files等anything in your system,相应速度非常快，windows上替代Spotlight没有问题。我的习惯是删光桌面所有的快捷键，只留一个垃圾桶，换一张喜欢的壁纸，开机打开软件查找文件就靠listary,这感觉倍爽。listary也有pro版，多加主题定制，关键词定制搜索等，我觉得怀着感恩的心free版够用了。 Pingfang, Monaco, Menlo, Source code pro以上的字体可以在点击在链接网站（求字体网，这个网站还蛮不错的哦）中找到，自行下载安装。windows安装字体在控制面板，小图标化的最后一个字体项目中。windows接受ttf格式的字体，下载完成后直接把ttf格式拖进到字体库中即可。从此再也不用忍受windows默认的体验不好的字体，有的app可能需要自己设置字体，系统有的字体都可以设置。自己喜欢什么字体也可以定向安装，个人比较推荐编程、阅读用以上的字体。 Cmdermac上用惯了iterm2 , fish shell,oh my zsh 你还能忍受window cmd？ 转windows不爽的地方就是cmd体验极其的差，从此不能愉快的用linux命令了。后来返现一个shell蛮好用，感觉cmder还是比不上mac上前面几个shell, cmder内也有powershell，可以启动时候自行切换，但是我觉得ps还没有cmder默认启动的好用。cmder用到现在返现两个缺点： 反应速度过慢，运行一个简单命令，通常需要1~2秒才能运行完成，复杂的就更慢了，比如简单的cd命令都需要卡一下，不知道是不是硬件配置、windows系统或者shell本身的问题。 git 没有现有分支status的状态提示，每次还需要git status 一次，还好cmder可以显示现在分支，不需要git branch。其他的地方没有什么可以诟病的，还可以在设置里设置主题样式，不仅可以使用windows命令，还可以使用linux命令（这个太棒了），完全是一个windows上优秀的仿生cmd shell。官网上建议下载full版本的，带有git和其他的linux命令。cmder快捷键双Tab 用于补全Ctrl+T 建立新页Ctrl+W 关闭标签页Ctrl+Tab 切换标签页Alt+F4 关闭所有标签页Ctrl+1 切换到第一个页签，Ctrl+2同理Alt + enter 切换到全屏状态修改 λ 提示符为 $默认cmder是λ提示符，想要无痛转移成可爱的$,也是有办法的修改安装包目录 vendor 下的 clink.lua 文件搜索lambda,λ改成$保存重启就可以了。 Chocolatey另一个命令行强化工具，homebrew软件包管理工具，一行命令就可以完全install、search、drop、upgrade你的app,解放双手利器。但是，windows上并不支持homebrew，悲伤。好东西所有平台都会存在，Chocolatey就是类似的工具，可以安装node,git,python,ruby,jdk,chrome,sublime等等。安装(管理员权限)1@\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" &amp;&amp; SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" 更新1choco upgrade chocolatey 常用命令12345choco install softwareName //安装choco search softwareName --id-starts-with //查找列表choco upgrade softwareName //更新choco uninstall softwareName //卸载choco info softwareName //软件信息 Vscode这个不解释，本来就是微软的东西,widnows肯定必须存在，各种平台兼容，代码编辑利器，启动快，插件多，主题多，自带版本控制。直接点击标题官网下载，快速有效。本来用sublime text系列后来用了vscode以后就转了。 Shadowsocks国内网络的限制，想看一看外面的世界还是尽早网络翻墙，尤其是做技术这一块的，靠百度几乎很难能找到你想要的答案。Shadowsocks网络还是蛮稳定的，十几刀一年还是让我们这些吃瓜群众能够接受的。 其他神器CLCL 原来mac上用的是clipmenu，windows上用的就是CLCL，剪切板工具。能够让你轻松的粘贴几十个剪切板的历史记录，省去了来回的复制的麻烦。此外还有template功能，自定义粘贴项目。 Beyondcompare 对比文件可视化工具神器，尤其在作为git mergetool来用，解决冲突、修改查看历史版本记录很方便。把bc配置git的mergetool其实也很简单，打开git的.gitconfig，windows上的此文件一般位于C:\\Users\\usrname下面，修改里面的mergetool字段内容如下(如果你也是bc4的话，user字段不用管):1234567891011[user]truename = xzhangtrueemail = xzhang@xx.com[merge] tool = bc4[mergetool \"bc4\"] cmd = \"\\\"c:/app/Beyond Compare 4/BComp.exe\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$MERGED\\\"\"[diff] tool = bc4[difftool \"bc4\"] cmd = \"\\\"c:/app/Beyond Compare 4/BComp.exe\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\"\" Fiddler mac上一般都会用charles小茶壶或者whistle做http或者https相关的网络请求代理工作,可以进行拦截分析请求、包装请求、本地调试和代理本地或线上资源开发调试等。而windows上用的工具就是Fiddler，差不多能出色满足同样的工作。如何使用基本功能官网和其他博客很多介绍，我还没详细深入研究更为强大的功能，基本使用的已经满足日常，所以这里就不是重点。 AltDrag 这个针对多屏比较好用，鼠标的focus会随着鼠标的位置移动，也就是可以在鼠标的位置滚动滑轮，这个mac记得好像也有，windows上增加这个感觉很赞，另外windows上只能拖拽顶部或者底部，并不能拖拽窗口的body去移动位置，AltDrag通过按住alt键就可以实现轻松拖拽。 如果发现其他更好的windows软件推荐，欢迎补充。 原创内容，欢迎交流转载请注明出处","categories":[{"name":"windows","slug":"windows","permalink":"https://joacycode.github.io/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joacycode.github.io/tags/windows/"}],"keywords":[{"name":"windows","slug":"windows","permalink":"https://joacycode.github.io/categories/windows/"}]},{"title":"根据唯一标识进行UI定制化","slug":"20171219other","date":"2017-12-19T10:15:43.000Z","updated":"2021-09-26T02:00:01.900Z","comments":true,"path":"posts/4d3fd604/","link":"","permalink":"https://joacycode.github.io/posts/4d3fd604/","excerpt":"UI可定制的地方： 字体 图片图标背景 文案 位置 数量 外观（形状背景） 请求地址（通过标识的更改）","text":"UI可定制的地方： 字体 图片图标背景 文案 位置 数量 外观（形状背景） 请求地址（通过标识的更改） 一个简单的栗子12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style&gt; .container &#123;position: relative;background: #eee;width: 500px;height: 500px;&#125; .container div.text&#123; font-size: 14px; color: black; font-family: 'pingFang-HK'; &#125; .container div.img&#123; width: 200px; height: 200px; background:url(/static/old.png) no-repeat; &#125; .container div.bg.shape&#123; background: black; color: #fff; width: 300px; height: 100px; &#125; .container div.postions&#123; width: 100%; height: 50px; background: #aaa; position: absolute; left: 0px; bottom: 0px; z-index: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"text\"&gt;we are defalut black,but now..&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"bg shape\"&gt;change bg color width height...&lt;/div&gt; &lt;div class=\"postions\"&gt;We were in the bottom，but now..&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面就是一个简单的静态页面，只要通过最简单的样式覆盖方式就可以实现样式的简单变更 覆盖样式注意后面的样式覆盖前面的样式是在相同权重的情况下，不同权重之间覆盖容易出现问题。例如#idA .classA p这个的权重是100+10+1，后面的覆盖样式的写法也要达到这样的权重。如果写成p这样是覆盖不了的，虽然样式后置了但是权重低。无条件使用!important（权重高于内联）和内联样式（权重1000）style=&quot;&quot;的权重最高，无论如何后置和增加权重值都达不到效果覆盖的效果的，注意谨慎使用。如果要覆盖前面的样式，需要做的就是把需要做调整的样式的选择器组拷到下面做样式重写 1234567891011121314151617.container div.text&#123; font-size: 16px; color: blue; font-family: 'pingFang-HK';&#125;.container div.img&#123; background:url(/static/new.png);&#125;.container div.bg.shape&#123; background: blue; color: red; width: 400px; height: 200px;&#125;.container div.postions&#123; top: 100px;&#125; 好了这样就似乎完成了一个简单的小需求，修改了文字颜色，背景颜色，大小，位置。 进一步修改现有UI如果是修改文案呢？在定制化中我不想要某个元素了，该如何修改元素的数量呢？随着定制化的深入用户点击某个按钮的请求地址的也要发生变化，这些好像不能用通过样式的覆盖去达到需求了。解决这个问题其实很简单【莫装X:)，白了少年头】 如果你的页面是在服务端做渲染然后呈现给用户的，那么就用服务端的模板引擎在服务端解决这件事，比如java的模板引擎freemaker， node可以用Nunjucks。 如果你是在我们客服端去做渲染页面的，你可以使用doTjs。 通过操作dom方式，你说你既不想在服务端做，又不想用模板引擎方式，那只有操作dom方式了，或者利用write方式直接写，反正不怎么推荐。 这里不是介绍怎么使用引擎的，所以具体用法大致就这样: page.jst12345678&lt;div class=\"container\"&gt; &lt;div class=\"text\"&gt;&#123;&#123;= it.text&#125;&#125;&lt;/div&gt; &#123;&#123;? it.showImg&#125;&#125; &lt;div class=\"img\"&gt;&lt;/div&gt; &#123;&#123;?&#125;&#125; &lt;div class=\"bg shape &#123;&#123;= it.requestClassName&#125;&#125;\"&gt;&#123;&#123;= it.shapetext&#125;&#125;&lt;/div&gt; &lt;div class=\"postions\"&gt;We were in the bottom，but now..&lt;/div&gt;&lt;/div&gt; compile.js12345import page from '/page.jst'// 1. 编译模板函数var tempFn = doT.template(page);// 2. 多次使用模板函数var resultText = tempFn(&#123;text: 'new text',showImg:false,requestClassName:'req1',shapetext:'new text'&#125;); 这样我们就可以通过js传入唯一标识去进一步实现定制化到目前为止所做的只是简单的满足需求，去做一些样式覆盖文案或者id、class的替换工作，距离深层次的定制化其实还有很长远的路要走… 简单的封装根据前端唯一标识定制化，也可以传回唯一标示请求配置数据，这涉及到后台配置系统，配置表等等。先从最近刚做的根据pid定制样式，在还未使用配置系统的情况下举个例子A是产品方，B，C，D，E是业务方，A需要根据BCDE的UI特点去分别满足他们的需求，如果是以后有更多的业务方还需要同样的满足。就算没有也业务方，其实时间空间也可以成为自己的业务需求方：早晨的UI和晚上的UI不同，北京地区的IP和上海地区的IP用户UI也不同，思考方向？总不能来一个业务就重新堆砌一堆代码，有句话叫以不变应万变，这里是以最小的变化应对千千万万个需求。不同的业务方会有不同的id,这里的id暂且可以称为Pid，不同的环境终端也可以做标识（pc,h5）,所以可以用这两个唯一标识作为参数去传入一个方法中，这个方法就是用来改变UI的。 12345678910111213141516171819202122232425262728293031323334/** * Created by xzhang on 2017/12/18. */function customByPid(pid,env)&#123; if(typeof pid !== 'string' || typeof env !== 'string') &#123; throw new Error('arguments is null or not typeof string'); &#125;; var cssData = &#123;&#125;; // 样式数据 作为write写入的变量使用 window.tempData = &#123;&#125;; // 模板引擎数据，用来改变文案，数量，请求等 var cssCover_pc,cssCover_h5; switch (pid) &#123; case '123456': tempData.text= 'new text'; tempData.shapetext= 'new shapetext'; tempData.showImg= true; tempData.requestClassName= 'req1'; cssData.imgSuffix = window.imgSuffix = '_blue'; cssData.txtcolor = '#666'; cssData.bgcolor = '#ffe400'; if(env === 'pc')&#123; cssData.bg_step = '#fcf2a2'; cssData.src_img = '/static/new.png'; &#125; break; default: break; &#125; cssCover_h5 = '&lt;style&gt;&lt;/style&gt;'; cssCover_pc = '&lt;style&gt;&lt;/style&gt;'; if(env === 'pc')&#123; document.write(cssCover_pc); &#125;else if(env === 'h5')&#123; document.write(cssCover_h5); &#125; 因为tempData是挂载到window上的，因此它是全局变量可以被doTJs模板引擎作为数据参数使用。调用方法 1customByPid('123456','pc') 这样就可以只根据pid和目前的环境终端去自动生成我们需要的UI了 配置系统与配置表、配置项未完待续，持续更新深入定制化配置系统和配置表 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"https://joacycode.github.io/tags/css/"},{"name":"定制化","slug":"定制化","permalink":"https://joacycode.github.io/tags/定制化/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"各种浏览器咋实现元素的全屏模式","slug":"20170914js","date":"2017-09-14T00:00:00.000Z","updated":"2021-09-26T02:00:01.899Z","comments":true,"path":"posts/37a4883/","link":"","permalink":"https://joacycode.github.io/posts/37a4883/","excerpt":"最近自己做H5的播放器，里面的各种按钮都要悉数去做，去调整样式，详细的属性方法事件在我另一篇‘js基础核心梳理之Video’里有堆，可以去全面的做个概览。却没有发现有全屏播放这个方法或者属性，不知道未来会不会封装这个方法进去。比如有个属性叫fullScreen设置为true就可以全屏显示。既然没有那就查查资料自己封装一个全屏方法，原则上市场上存在的产品现象背后都有可实现的方法，你就可以去做。 以下是实现全屏和退出全屏的各种浏览器兼容方法，也可以利用 fullScreenElement 和 fullScreenEnabled去检测某个全屏的元素和全屏状态。","text":"最近自己做H5的播放器，里面的各种按钮都要悉数去做，去调整样式，详细的属性方法事件在我另一篇‘js基础核心梳理之Video’里有堆，可以去全面的做个概览。却没有发现有全屏播放这个方法或者属性，不知道未来会不会封装这个方法进去。比如有个属性叫fullScreen设置为true就可以全屏显示。既然没有那就查查资料自己封装一个全屏方法，原则上市场上存在的产品现象背后都有可实现的方法，你就可以去做。 以下是实现全屏和退出全屏的各种浏览器兼容方法，也可以利用 fullScreenElement 和 fullScreenEnabled去检测某个全屏的元素和全屏状态。 全屏模式12345678910111213function launchFullscreen(element) &#123; if(element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if(element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125; else if(element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125;&#125;launchFullScreen(document.documentElement); // 整个网页launchFullScreen(document.getElementById(\"videoElement\")); // 某个页面元素 退出全屏模式各种浏览器都提供了一个非常有用的全屏模式时的css样式规则，直接套用即可 12345678910function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125;exitFullscreen();//exitFullscreen只能由document对象调用，而不是启动全屏时传入的对象。 全屏模式属性1234var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled;document.fullScreenElement: 全屏显示的网页元素。document.fullScreenEnabled: 判断当前是否处于全屏状态 全屏样式CSS123456789101112131415161718192021222324252627:-webkit-full-screen &#123; /* properties */&#125;:-moz-full-screen &#123; /* properties */&#125;:-ms-fullscreen &#123; /* properties */&#125;:full-screen &#123; /*pre-spec */ /* properties */&#125;:fullscreen &#123; /* spec */ /* properties */&#125;/* deeper elements */:-webkit-full-screen video &#123; width: 100%; height: 100%;&#125;/* styling the backdrop*/::backdrop &#123; /* properties */&#125;::-ms-backdrop &#123; /* properties */&#125; 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"video","slug":"video","permalink":"https://joacycode.github.io/tags/video/"},{"name":"全屏","slug":"全屏","permalink":"https://joacycode.github.io/tags/全屏/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"柯里化函数是个什么","slug":"20170820js","date":"2017-08-20T00:00:00.000Z","updated":"2021-09-26T02:00:01.901Z","comments":true,"path":"posts/d4c5a626/","link":"","permalink":"https://joacycode.github.io/posts/d4c5a626/","excerpt":"最近碰到这个概念，就来做个笔记，啥都不说了上定义。 柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。 talk is cheap,show me the code如果你有js基础，看看下面的代码就知道柯里化是咋回事了。","text":"最近碰到这个概念，就来做个笔记，啥都不说了上定义。 柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。 talk is cheap,show me the code如果你有js基础，看看下面的代码就知道柯里化是咋回事了。 123456789101112131415161718var currying = function () &#123; var _args = []; return function () &#123; if (arguments.length === 0) &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; [].push.apply(_args, [].slice.call(arguments)); return arguments.callee;//返回当前执行函数 &#125;&#125;;var sum = currying();console.log(sum); // Function // 调用形式灵活，一次调用可输入一个或者多个参数，并支持链式调用sum(1,2)(3); sum(4);console.log(sum()); // 10 更通用的柯里化1234567891011121314151617181920212223var currying = function (fn) &#123; var _args = []; return function () &#123; if (arguments.length === 0) &#123; return fn.apply(this, _args); &#125; [].push.apply(_args, [].slice.call(arguments)); return arguments.callee;//返回当前执行函数 &#125;&#125;;var sum = currying(multi);console.log(sum); // Function sum(1,2)(3); sum(4);console.log(sum()); // 10var multi=function () &#123; var total = 0; for (var i = 0, c; c = arguments[i++];) &#123; total += c; &#125; return total;&#125;; 简单来说因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。满足条件的时候它每次都会返回一个新的函数，新的函数又可以接受新的参数，直到延迟到最后一次不满足条件进行求值计算。柯里化这个概念其实就是函数式编程思想, 用已有的函数组合出新的函数, 而柯里化每消费一个参数, 都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段, 并且使得接口更为流畅 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"柯里化","slug":"柯里化","permalink":"https://joacycode.github.io/tags/柯里化/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"来，认识下XMLHttpRequest2","slug":"20170713js","date":"2017-07-13T00:00:00.000Z","updated":"2021-09-26T02:00:01.899Z","comments":true,"path":"posts/df4bb76e/","link":"","permalink":"https://joacycode.github.io/posts/df4bb76e/","excerpt":"XMLHttpRequest综述XMLHttpRequest在维基百科的定义”XMLHttpRequest (XHR) is an API in the form of an object whose methods transfer data between a web browser and a web server.” 它是一个在服务端和客户端之间进行传输数据的浏览器接口，说白了就是HTTP(S)的通信，依赖于浏览器的javascript环境。通信的数据格式限于XML,JSON,HTML,plain text。但是这个接口的最初版本，各个浏览器厂家的实现也不尽相同，没有被标准化。这么下去也不是个事儿，技术总得进步，接口总得统一，不然不仅开发者闹情绪，用户都快不满足了，后来html5出现以后，这个标准化的工作就提上了日程，谁去做？当然W3C那帮老大哥啊，凡是和www有关的草案，正式标准都是得那发话。所以众望所归，这个XMLHttpRequest的标准草案在2008年落成，因为增加了许多新的技能，所以叫XMLHttpRequest有点赶不上时代潮流了，叫XMLHttpRequest plus？这个名字有点apple，还是叫XMLHttpRequest level2吧。到底增加了哪些功能了呢？那先研究下XMLHttpRequest level1基础？那还废什么话直接捋袖子干~在控制台吧XMLHttpRequest打出来会发现他是一个构造函数，是一个可以继承的类，要使用其上的接口方法属性需要实例化这个方法。新建一个XMLHttpRequest的实例","text":"XMLHttpRequest综述XMLHttpRequest在维基百科的定义”XMLHttpRequest (XHR) is an API in the form of an object whose methods transfer data between a web browser and a web server.” 它是一个在服务端和客户端之间进行传输数据的浏览器接口，说白了就是HTTP(S)的通信，依赖于浏览器的javascript环境。通信的数据格式限于XML,JSON,HTML,plain text。但是这个接口的最初版本，各个浏览器厂家的实现也不尽相同，没有被标准化。这么下去也不是个事儿，技术总得进步，接口总得统一，不然不仅开发者闹情绪，用户都快不满足了，后来html5出现以后，这个标准化的工作就提上了日程，谁去做？当然W3C那帮老大哥啊，凡是和www有关的草案，正式标准都是得那发话。所以众望所归，这个XMLHttpRequest的标准草案在2008年落成，因为增加了许多新的技能，所以叫XMLHttpRequest有点赶不上时代潮流了，叫XMLHttpRequest plus？这个名字有点apple，还是叫XMLHttpRequest level2吧。到底增加了哪些功能了呢？那先研究下XMLHttpRequest level1基础？那还废什么话直接捋袖子干~在控制台吧XMLHttpRequest打出来会发现他是一个构造函数，是一个可以继承的类，要使用其上的接口方法属性需要实例化这个方法。新建一个XMLHttpRequest的实例1var xhr = new XMLHttpRequest(); 向服务端发送接受数据的请求 12xhr.open(METHOD, URL);xhr.send(BODY); 服务端主机做出返回要找个事件onreadystatechange监听啊，不仅要监听还要做出反应（回调）1xhr.onreadystatechange = callback; 我这个人喜欢总结，喜欢举一反三，你光秃秃给我看XMLHttpRequest这个对象上的几个属性方法，真的能憋死我，就算我去控制台打印调试，我也得一个不落的都给总结了，所以新老版本的XMLHttpRequest属性方法事件都在后面躺着呢，以后记性不好也可以参考参考，不然这日子没法过。 XMLHttpRequest这样看没毛病啊？ 谁说他有毛病了，你能说当年的”286”有毛病么？不能，时代在发展，人类在进步，不要嫌弃为我们做过贡献的革命好同志。只是我与XMLHttpRequest不相见已二余年，到现在我忘不掉的还是那个夜晚，从二进制坑里爬不出来我的背影。 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”，只能向同一域名的服务器请求数据 XMLHttpRequest2最后一条可以说比较过分了，你让我跨域的咋办，jsonp? 那我不用get呢，iframe? 我想静静，不知道她想我么。所以！！ 新一代的XMLHttpRequest出现了，来数一数哪些东西可以让你爬出坑。 增加了timeout属性，可以设置HTTP请求的时限,超时直接处理。12xhr.timeout =timeout;xhr.ontimeout = callback; HTML5新增了一个FormData对象，可以模拟表单，直接传送这个FormData对象,与提交网页表单的效果完全一样123var formData = new FormData();// 新建一个FormData对象formData.append('username', '张三');// 添加一个额外表单项xhr.send(formData); FormData对象也可以用来对页面上现有的 HTMLFormElement 进行初始化。123var form = document.getElementById(‘myform');// 获取网页表单的值var formData = new FormData(form); 新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件跨域资源共享（CORS）可以向不同域名的服务器发出HTTP请求 这叫做”跨域资源共享”（Cross-origin resource sharing，简称CORS）使用”跨域资源共享”的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种”跨域 接收二进制数据1. 旧做法 ,改写MIMEType ,详细的有兴趣自己查较老的做法是改写数据的MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集123456789101112131415var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);// Hack to pass bytes through unprocessed.xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; var binStr = this.responseText; for (var i = 0, len = binStr.length; i &lt; len; ++i) &#123; var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; // byte at offset i &#125; &#125;&#125;;xhr.send(); 2.responseType属性123456//把responseType设为blob，表示服务器传回的是二进制对象。var xhr = new XMLHttpRequest();xhr.open('GET', ‘/path/to/image.png');xhr.responseType = ‘blob';//接收数据的时候，用浏览器自带的Blob对象即可。var blob = new Blob([xhr.response], &#123;type: ‘image/png'&#125;); 事件 on+onprogress：传送数据的时候，返回进度信息调用方式xhr.upload.onprogressonload：传输成功完成。onabort：传输被用户取消。onerror：传输中出现错误。onloadstart：传输开始。onloadEnd：传输结束，但是不知道成功还是失败。 1234567891011&lt;progress min=\"0\" max=\"100\" value=\"0\"&gt;0% complete&lt;/progress&gt;&lt;script&gt; xhr.upload.onprogress = function(e) &#123; if (e.lengthComputable) &#123; progressBar.value = (e.loaded / e.total) * 100; progressBar.textContent = progressBar.value; &#125; &#125;; xhr.onload=fn; //xhr.addEventLisetener(\"load\",fn);&lt;/script&gt; XMLHttpRequest api属性readyState0 表示初始化状态，XMLHttpRequest对象已经创建或者abort()重置1 表示open()方法已经调用，但是未send(),请求并没有被发送2 表示send()方法已经调用，http请求到达服务器，未收到响应3 所有的响应头都已收到，响应体开始接收但未完成4 http响应已经完全接收每次这个属性值增加的时候，都会触发onreadystatechange()事件句柄 status由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。==当readyState小于 3 的时候读取这一属性会导致一个异常==。 statusText这个属性用名称而不是数字指定了请求的 HTTP的状态代码。也就是说，当状态为 200 的时候它是 “OK”，当状态为 404 的时候它是 “Not Found”。和 status 属性一样，==当 readyState 小于 3 的时候读取这一属性会导致一个异常。== responseText目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。 responseXML对请求的响应，解析为 XML 并作为 Document 对象返回。 response返回 responseType 设置过的格式的数据 responseType返回什么格式的数据 ==[text,arraybuffer,blob,document] 默认text== 事件onreadystatechange每次 readyState 属性改变的时候调用的事件句柄函数。当 readyState 为 3 时，它也可能调用多次。 方法abort()取消当前响应，关闭连接并且结束任何未决的网络活动。这个方法把 XMLHttpRequest 对象重置为 readyState 为0的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。 getAllResponseHeaders()把 HTTP 响应头部作为未解析的字符串返回。如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “\\r\\n” 隔开。 getResponseHeader()返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。 open(method, url, async, username, password)初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求。 send(body)发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。 setRequestHeader(name, value)name 参数是要设置的头部的名称。这个参数不应该包括空白、冒号或换行。value 参数是头部的值。这个参数不应该包括换行向一个打开但未发送的请求设置或添加一个 HTTP 请求。 说明setRequestHeader() 方法指定了一个 HTTP 请求的头部，它应该包含在通过后续 send() 调用而发布的请求中。这个方法只有当 readyState 为 1 的时候才能调用，例如，在调用了open() 之后，但在调用 send() 之前。如果带有指定名称的头部已经被指定了，这个头部的新值就是：之前指定的值，加上逗号、空白以及这个调用指定的值。如果 open() 调用指定了认证资格，XMLHttpRequest 自动发送一个适当的 Authorization 请求头部。但是，你可以使用 setRequestHeader() 来添加这个头部。类似地，如果 Web 服务器已经保存了和传递给open() 的 URL 相关联的cookie，适当的 Cookie 或 Cookie2 头部也自动地包含到请求中。可以通过调用 setRequestHeader()来把这些 cookie 添加到头部。XMLHttpRequest 也可以为 User-Agent 头部提供一个默认值。如果它这么做，你为该头部指定的任何值都会添加到这个默认值后面。有些请求头部由 XMLHttpRequest 自动设置而不是由这个方法设置，以符合 HTTP 协议。这包括如下和代理相关的头部：HostConnectionKeep-AliveAccept-charsetAccept-EncodingIf-Modified-SinceIf-None-MatchIf-RangeRange 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"XMLHttpRequest2","slug":"XMLHttpRequest2","permalink":"https://joacycode.github.io/tags/XMLHttpRequest2/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"https://joacycode.github.io/tags/XMLHttpRequest/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"重新认知下History这家伙","slug":"20170613js","date":"2017-06-13T00:00:00.000Z","updated":"2021-09-26T02:00:01.898Z","comments":true,"path":"posts/ab959e28/","link":"","permalink":"https://joacycode.github.io/posts/ab959e28/","excerpt":"DOM中的window对象通过window.history方法提供了对浏览器历史记录的读取，让你可以在用户的访问记录中前进和后退。从HTML5开始，我们可以开始操作这个历史记录堆栈。 1.window属性history的方法使用back(),forward(),和go()方法可以在用户的历史记录中前进和后退 用户后退行为,这个方法会像用户点击了浏览器工具栏上的返回键一样。1window.history.back();","text":"DOM中的window对象通过window.history方法提供了对浏览器历史记录的读取，让你可以在用户的访问记录中前进和后退。从HTML5开始，我们可以开始操作这个历史记录堆栈。 1.window属性history的方法使用back(),forward(),和go()方法可以在用户的历史记录中前进和后退 用户后退行为,这个方法会像用户点击了浏览器工具栏上的返回键一样。1window.history.back();用户前进行为：1window.history.forward(); 使用go()方法从session历史中载入特定的页面，当然，你可以前进或者后退多个页面。12//向后移动一页：window.history.go(-1); 12//向前移动一页：window.history.go(1); 还可以通过检查浏览器历史记录的length属性来找到历史记录堆栈中的页面总数。1var numberOfEntries = window.history.length; 注意:IE支持向go()方法传URL参数。 2.添加和修改history实体Html5引入了histtory.pushState() 和 history.replaceState() 这两个方法，他们允许添加和修改history实体。同时，这些方法会和 window.onpopstate 事件一起工作。使用history.pushState()方法来修改referrer,这种方法可以被用在经过修改状态后而为xmlhttpRequest对象创建的http header中,这个referrer会是创建XMLHttpRequest时document的URL。 pushState 用于向 history 添加当前页面的记录，而 replaceState 和 pushState 的用法完全一样，唯一的区别就是它用于修改当前页面在 history 中的记录。假设 https://youku.com/foo.html 页面执行了下面的Js12var stateObj = &#123; foo: \"bar\" &#125;; history.pushState(stateObj, \"page 2\", \"bar.html\"); 这种方法将会使url地址栏显示https://youku.com/bar.html，但浏览器不会加载bar.html页面，即使这个页面存在也不会加载。现在再次假设用户继续访问https://tudou.com，然后点击后退。这时，url地址栏将会出现https://youku.com/bar.html，页面会得到popstate事件，这个状态对象会包含一个stateObj的copy。这个页面看起来像foo.html。这时，我们再次点击后退，URL将变成 https://youku.com/foo.html，document将得到另一个popstate事件和为null的state对象,这次的返回动作并没有改变文档的内容。 pushState方法pushState()有三个参数:state对象，标题，URL(可选)。具体细节： state对象state对象是一个JavaScript对象，它关系到由pushState()方法创建出来的新的history实体。用以存储关于你所要插入到历史，记录的条目的相关信息。State对象可以是任何Json字符串。因为firefox会使用用户的硬盘来存取state对象，这个对象的最大存储空间为640k。如果大于这个数 值，则pushState()方法会抛出一个异常。如果确实需要更多的空间来存储，请使用本地存储。 title[firefox]未来可能会被使用上的一个参数，目前使用无实际的意义。现在最安全的使用方式是传一个空字符串，以防止将来的修改。或者可以传一个简短的标题来表示state。 URL这个参数用来传递新的history实体的URL，注意浏览器将不会在调用pushState()方法后加载这个URL，但也许会过一会尝试加载这个URL。例如在用户重启了浏览器后，新的url可以不是绝对路径。如果是相对路径，那么它会相对于现有的url。新的url必须和现有的url同域，否则pushState()将抛出异常。这个参数是选填的，如果为空，则会被置为document当前的url。某种意义上来说，调用pushState()方法很像设置了window.location = “#foo”,这两者都会创建和激活另一个关联到当前document的history实体，但pushState()另外有一些优点： 新的url可以是任何和当前url同域的url，相比之下，如果只设置hash，window.location会保持在同一个document。如果不需要，你可以不修改url。对比而言，设置window.location = “#foo”;仅产生新的history实体，如果你当前的hash不是#foo你可以将任意的数据与你的新history实体关联。使用基于hash的方法，需要将所有相关的数据编码为一个短字符串。 注意，pushState()方法不会使hashchange时间发生，即使是新旧url只是hash不同。 replaceState()方法1history.replaceState() 用起来很像pushState()，除了replaceState()是用来修改当前的history实体而不是创建一个新的。这个方法有时会很有用，当 你需要对某些用户行为作反应而更新一个state对象或者当前history实体时，可以使用它来更新state对象或者当前history实体的url。 popstate事件调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).详见window.onpopstate 12345678910window.onpopstate = function(event) &#123; alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));&#125;;//绑定事件处理函数. history.pushState(&#123;page: 1&#125;, \"title 1\", \"?page=1\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1history.pushState(&#123;page: 2&#125;, \"title 2\", \"?page=2\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2history.replaceState(&#123;page: 3&#125;, \"title 3\", \"?page=3\"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3history.back(); // 弹出 \"location: http://example.com/example.html?page=1, state: &#123;\"page\":1&#125;\"history.back(); // 弹出 \"location: http://example.com/example.html, state: nullhistory.go(2); // 弹出 \"location: http://example.com/example.html?page=3, state: &#123;\"page\":3&#125; 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"history","slug":"history","permalink":"https://joacycode.github.io/tags/history/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"git命令实战记录","slug":"20170428js","date":"2017-04-28T00:00:00.000Z","updated":"2021-09-26T02:00:01.898Z","comments":true,"path":"posts/f370b2d3/","link":"","permalink":"https://joacycode.github.io/posts/f370b2d3/","excerpt":"这里为了方便查字典，整理了常用的git操作，正常开发工作情况下应该很全了，如果随后遇到新的奇淫操作会不断更新的~ 生成ssh key12ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"ssh-keygen -t rsa -C \"joacycode@163.com 用户名、邮箱配置12git config user.name yourname --localgit config user.email yourname@emmail.com --local","text":"这里为了方便查字典，整理了常用的git操作，正常开发工作情况下应该很全了，如果随后遇到新的奇淫操作会不断更新的~ 生成ssh key12ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"ssh-keygen -t rsa -C \"joacycode@163.com 用户名、邮箱配置12git config user.name yourname --localgit config user.email yourname@emmail.com --local 本地项目关联远程仓库123456789101112131415# 切换到本地项目地址,初始化项目。该步骤会创建一个.git文件夹是附属于该仓库的工作树git initgit add .git commit -m 'initial commit'# Git上已有仓库，不克隆的情况下关联到本地仓库，本地仓库下运行此命令,可能需要执行# git config --global push.default matching# 使得push命令默认push到github的同名仓库中git remote add origin git@service:path/xx.git# 把本地项目push到远程github仓库push -u origin master # Git远程分支和本地分支的关联未创建git branch --set-upstream branchName origin/branchName 克隆代码库1git clone git@[git address]:[gitname] [local repo-name] 创建分支1234git branch branchName # 基于本地创建分支git push origin branchName # 推送本地分支git branch branchName origin/branchName # 基于远程创建分支git checkout -b branchName origin/branchName # 创建分支并切换到此分支（远程） 查看分支1234git branch # 列出本地所有分支git branch -r # 列出远程所有分支git branch -a # 列出所有分支(远程和本地)git branch -avv # 列出所有分支(并显示追踪track关系) 删除分支12git branch -d[-D] branchName 删除本地分支git push origin --delete branchName删除远程分支 分支重命名1git branch -m old-name new-name 删除远程分支方案123#备份远程分支#删除远程分支git push origin :branch 切换分支1git checkout branchName 更新分支12345# 更新分支内容git pull origin [branch name]# 拉取远程最新列表分支git fetch origin 合并分支切换到需要合并的分支1git checkout [branchName] 禁用fast-forward的合并,否则合并的分支提交记录会带到主分支1git merge --no-ff -m ”description” mergeBranch 解决目录下的冲突解决冲突(手动解决 外部工具解决beyondCompare，解决冲突目前推荐vscode编辑器自带的冲突解决)，重新构建所有冲突的文件 12345678# 解决本次合并的所有冲突git mergetool# 解决特定文件的冲突git mergetool src/js/g.js# 查看编辑gitconfig [mergetool difftool alias]vim ~/.gitconfig 本地分支与远程分支绑定1234git push -u origin [branchName] # orgit push --set-upstream origin [branchName] #第一次推git push # orgit push origin branchName #绑定后的推送 更新master1git pull --rebase origin master 恢复代码 未推送至远程都可以用reset 1234git reset --hard origin/branchName # 放弃本地修改和远程保持一致git reset --hard [commit id] # 恢复到指定版本git reset --hard HEAD # HEAD^ HEAD^^ HEAD~Ngit reset --hard file[文件地址] 已添加到暂存区 (git add后) 12git reset HEAD file[文件地址] # 从版本库恢复内容到暂存区git checkout --file[文件地址] # 从暂存区恢复到工作区,丢掉工作区 直接丢弃工作区 (还未 git add) 1git checkout --file 已推送到远程的分支，需要重新更新再强制推送 1git push -f 迁移代码仓库需要迁移的仓库地址git-old-url/some.git新的仓库地址git-new-url/some.git12345678910# 克隆裸版本库，包含版本库历史的各个分支和提交记录git clone --bare git-old-url/some.git# 进入本地的裸库some.gitcd some.git# 推送镜像到新git地址git push --mirror git-new-url/some.git# 删除裸库rm -rf some.git# 克隆新的地址仓库：git clone git-new-url/some.git 其他方式12# 更改远程remote地址git remote set-url origin git-new-url/some.git 远程版本回滚1234# 本地代码回滚到上一版本（或者指定版本）git reset --hard [commit id] # ^HEAD# 加入-f参数，强制提交，将强制更新远程端版本 慎用git push -f origin branchname 对比文件1234567891011121314151617181920# 对比两个分支文件git diff dev master -- [path]# 对比两个分支文件git diff dev:[path] master:[path] # 对比提交过的文件git diff [commit id 1] [commit id 2]# 对比工作区和暂存区git diff -- [PATH]# 对比工作区和版本库git diff HEAD -- [path]# 对比暂存区和版本库git diff --cached -- [PATH]# 比较本次合并的所有修改(只与提交前的记录比较)git difftool add操作123456# 保存所有操作git add -A # 保存删除和修改 但不包括新建git add -u # 保存新建和修改 但不包括删除git add . 查看当前分支commit id1git rev-parse HEAD 覆盖上一次提交的记录1git commit --amend -m 'msg' gitconfig12345678910111213141516~/.gitconfig[merge] tool = bcomp[mergetool] prompt = false keepBackup = false[mergetool \"bcomp\"] trustExitCode = true cmd = \"/usr/local/bin/bcomp\" \"$LOCAL\" \"$REMOTE\" \"$BASE\" \"$MERGED\"[diff] tool = bcomp[difftool] prompt = false[difftool \"bcomp\"] trustExitCode = true cmd = \"/usr/local/bin/bcomp\" \"$LOCAL\" \"$REMOTE\" 常用git Alias123456789101112131415[alias] s = status --short --branch pu = pull --rebase ca = commit --amend ci = commit -a -v br = branch bv = branch -vv co = checkout cb = checkout -b df = diff un = reset --hard HEAD uh = reset --hard HEAD^ ll = log --pretty=format:\"%C(yellow)%h%Cred%d\\\\ %Creset%s%Cblue\\\\ [%cn]\" --decorate --numstat ld = log --pretty=format:\"%C(yellow)%h\\\\ %C(green)%ad%Cred%d\\\\ %Creset%s%Cblue\\\\ [%cn]\" --decorate --date=short --graph ls = log --pretty=format:\"%C(green)%h\\\\ %C(yellow)[%ad]%Cred%d\\\\ %Creset%s%Cblue\\\\ [%cn]\" --decorate --date=relative 欢迎交流转载请注明出处","categories":[{"name":"git","slug":"git","permalink":"https://joacycode.github.io/categories/git/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://joacycode.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://joacycode.github.io/tags/git/"},{"name":"shell","slug":"shell","permalink":"https://joacycode.github.io/tags/shell/"}],"keywords":[{"name":"git","slug":"git","permalink":"https://joacycode.github.io/categories/git/"}]},{"title":"H5项目常见问题及注意事项","slug":"20170212h5","date":"2017-02-12T00:00:00.000Z","updated":"2021-09-26T02:00:01.899Z","comments":true,"path":"posts/262a55b/","link":"","permalink":"https://joacycode.github.io/posts/262a55b/","excerpt":"Meta基础知识：H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 12345678910111213141516171819202122232425//一、HTML页面结构&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;// width 设置viewport宽度，为一个正整数，或字符串‘device-width’// height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例，为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放//二、JS动态判断&lt;script&gt;var phoneWidth = parseInt(window.screen.width);var phoneScale = phoneWidth/640;var ua = navigator.userAgent;if (/Android (\\d+\\.\\d+)/.test(ua))&#123; var version = parseFloat(RegExp.$1); if(version&gt;2.3)&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi\"&gt;'); &#125;else&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\"&gt;'); &#125;&#125; else &#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\"&gt;');&#125;&lt;/script&gt;","text":"Meta基础知识：H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 12345678910111213141516171819202122232425//一、HTML页面结构&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;// width 设置viewport宽度，为一个正整数，或字符串‘device-width’// height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例，为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放//二、JS动态判断&lt;script&gt;var phoneWidth = parseInt(window.screen.width);var phoneScale = phoneWidth/640;var ua = navigator.userAgent;if (/Android (\\d+\\.\\d+)/.test(ua))&#123; var version = parseFloat(RegExp.$1); if(version&gt;2.3)&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi\"&gt;'); &#125;else&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\"&gt;'); &#125;&#125; else &#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\"&gt;');&#125;&lt;/script&gt; H5空白页基本meta标签12345678&lt;!-- 设置缩放 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\" /&gt;&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;&lt;meta name=\"format-detection\"content=\"telephone=no, email=no\" /&gt; PC端基础meta标签1234567891011121314151617&lt;!-- 页面关键词--&gt;&lt;meta name=\"keywords\" content=\"your tags\" /&gt;&lt;!-- 页面描述--&gt;&lt;meta name=\"description\" content=\"150 words\" /&gt;&lt;!-- 搜索引擎索引方式：robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。--&gt;&lt;meta name=\"robots\" content=\"index,follow\" /&gt;&lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --&gt; &lt;!-- 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。--&gt; &lt;meta http-equiv=\"refresh\" content=\"0;url=\" /&gt; 页面缓存设置1234&lt;!-- 清除缓存 --&gt;&lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"expires\" content=\"0\"&gt; 其他meta标签123456789101112131415161718192021222324252627&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;&lt;meta name=\"author\" content=\"author name\" /&gt; &lt;!-- 定义网页作者 --&gt;&lt;meta name=\"google\" content=\"index,follow\" /&gt;&lt;meta name=\"googlebot\" content=\"index,follow\" /&gt;&lt;meta name=\"verify\" content=\"index,follow\" /&gt; 移动端如何定义字体font-family12345678910111213141516@ --------------------------------------中文字体的英文名称@ 宋体 SimSun@ 黑体 SimHei@ 微信雅黑 Microsoft Yahei@ 微软正黑体 Microsoft JhengHei@ 新宋体 NSimSun@ 新细明体 MingLiU@ 细明体 MingLiU@ 标楷体 DFKai-SB@ 仿宋 FangSong@ 楷体 KaiTi@ 仿宋_GB2312 FangSong_GB2312@ 楷体_GB2312 KaiTi_GB2312 @@ 说明：中文字体多数使用宋体、雅黑，英文用Helveticabody &#123; font-family: Microsoft Yahei,SimSun,Helvetica; &#125; 打电话发短信写邮件怎么实现1234567891011121314151617181920212223242526// 一、打电话&lt;a href=\"tel:0755-10086\"&gt;打电话给:0755-10086&lt;/a&gt;// 二、发短信，winphone系统无效&lt;a href=\"sms:10086\"&gt;发短信给: 10086&lt;/a&gt;// 三、写邮件//注：在添加这些功能时，第一个功能以\"?\"开头，后面的以\"&amp;\"开头//1.普通邮件&lt;a href=\"mailto:863139978@qq.com\"&gt;点击我发邮件&lt;/a&gt;//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）&lt;a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net\"&gt;点击我发邮件&lt;/a&gt;//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）&lt;a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com\"&gt;点击我发邮件&lt;/a&gt;//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址&lt;a href=\"mailto:863139978@qq.com;384900096@qq.com\"&gt;点击我发邮件&lt;/a&gt;//5.包含主题，用?subject=&lt;a href=\"mailto:863139978@qq.com?subject=邮件主题\"&gt;点击我发邮件&lt;/a&gt;//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 &lt;a href=\"mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来\"&gt;点击我发邮件&lt;/a&gt;//7.内容包含链接，含http(s)://等的文本自动转化为链接&lt;a href=\"mailto:863139978@qq.com?body=http://www.baidu.com\"&gt;点击我发邮件&lt;/a&gt;//8.内容包含图片（PC不支持）&lt;a href=\"mailto:863139978@qq.com?body=&lt;img src='images/1.jpg' /&gt;\"&gt;点击我发邮件&lt;/a&gt;//9.完整示例&lt;a href=\"mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src='images/1.jpg' /&gt;\"&gt;点击我发邮件&lt;/a&gt; 移动端touch事件（区分webkit和winphone）123456789101112131415161718192021222324/* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */// 以下支持webkittouchstart——当手指触碰屏幕时候发生。不管当前有多少只手指touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动touchend——当手指离开屏幕时触发touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用//TouchEvent说明：touches：屏幕上所有手指的信息targetTouches：手指在目标区域的手指信息changedTouches：最近一次触发该事件的手指信息touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息//参数信息(changedTouches[0])clientX、clientY在显示区的坐标target：当前元素//事件响应顺序ontouchstart &gt; ontouchmove &gt; ontouchend &gt; onclick// 以下支持winphone 8MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html&#123;-ms-touch-action: none;&#125;可以阻止默认情况的发生：阻止页面滚动MSPointerUp——当手指离开屏幕时触发 移动端click屏幕产生200-300ms的延时响应lang:123456789101112说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。以下是历史原因，来源一个公司内一个同事的分享：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=\"#\"&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。//解决方案：fastclick可以解决在手机上点击事件的300ms延迟zepto的touch模块，tap事件也是为了解决在click的延迟问题 Rentina显示屏原理及设计方案1234567891011121314151617//说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;//其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px.css&#123;font-size:20px&#125;//image-set设计Rentina背景图image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。.css &#123; background: url(images/bg.jpg) no-repeat center; background: -webkit-image-set( url(images/bg.jpg) 1x, //支持image-set普通屏 url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan&#125; 点击元素产生背景或边框怎么去掉1234567891011121314//ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；//android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；//winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;去掉；//特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签a,button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符&#125; // 也可以 &lt;style&gt;* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;&lt;/style&gt;//winphone下&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; 美化表单元素123456789101112131415//一、使用appearance改变webkit浏览器的默认外观input,select &#123; -webkit-appearance:none; appearance: none; &#125;//二、winphone下，使用伪元素改变表单元素默认外观//1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰select::-ms-expand &#123; display:none; &#125;//2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display:none; &#125;//3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear &#123; display:none; &#125; 移动端字体单位font-size选择px还是rem1234// 如需适配多种移动设备，建议使用rem。以下为参考值：html &#123; font-size: 62.5%; &#125; //10*16 = 62.5%//设置12px字体 这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级body &#123; font-size:12px; font-size:1.2rem; &#125; 超实用的CSS样式123456789101112131415161718192021222324252627282930313233//去掉webkit的滚动条——display: none;//其他参数::-webkit-scrollba //滚动条整体部分::-webkit-scrollbar-thumb //滚动条内的小方块::-webkit-scrollbar-track //滚动条轨道::-webkit-scrollbar-button //滚动条轨道两端按钮::-webkit-scrollbar-track-piece //滚动条中间部分，内置轨道::-webkit-scrollbar-corner //边角，两个滚动条交汇处::-webkit-resizer //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件// 禁止长按链接与图片弹出菜单a,img &#123; -webkit-touch-callout: none &#125; // 禁止ios和android用户选中文字html,body &#123;-webkit-user-select:none; user-select: none; &#125;// 改变输入框placeholder的颜色值::-webkit-input-placeholder &#123; /* WebKit browsers */color: #999; &#125;:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */color: #999; &#125;::-moz-placeholder &#123; /* Mozilla Firefox 19+ */color: #999; &#125;:-ms-input-placeholder &#123; /* Internet Explorer 10+ */color: #999; &#125;input:focus::-webkit-input-placeholder&#123; color:#999; &#125;// android上去掉语音输入按钮input::-webkit-input-speech-button &#123;display: none&#125;// 阻止windows Phone的默认触摸事件/*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/html &#123; -ms-touch-action:none; &#125; //禁止winphone默认触摸事件 取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt; 手机拍照和上传图片123//IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持&lt;input type=\"file\" accept=\"images/*\" /&gt;&lt;input type=\"file\" accept=\"video/*\" /&gt; 屏幕旋转的事件和样式12345678910111213141516171819202122&lt;script&gt;//JS处理function orientInit()&#123; var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight?'landscape':'portrait'; if(orientChk =='lapdscape')&#123; //这里是横屏下需要执行的事件 &#125;else&#123; //这里是竖屏下需要执行的事件 &#125;&#125;orientInit();window.addEventListener('onorientationchange' in window?'orientationchange':'resize', function()&#123; setTimeout(orientInit, 100);&#125;,false) &lt;/script&gt;&lt;style&gt;//CSS处理//竖屏时样式@media all and (orientation:portrait)&#123; &#125;//横屏时样式@media all and (orientation:landscape)&#123; &#125;&lt;/style&gt; audio元素和video元素在ios和andriod中无法自动播放123456789101112131415161718192021222324//音频，写法一&lt;audio src=\"music/bg.mp3\" autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;//音频，写法二&lt;audio controls=\"controls\"&gt; &lt;source src=\"music/bg.ogg\" type=\"audio/ogg\"&gt;&lt;/source&gt; &lt;source src=\"music/bg.mp3\" type=\"audio/mpeg\"&gt;&lt;/source&gt; 优先播放音乐bg.ogg，不支持在播放bg.mp3&lt;/audio&gt;&lt;script&gt;//JS绑定自动播放（操作window时，播放音乐）$(window).one('touchstart', function()&#123; music.play();&#125;)//微信下兼容处理document.addEventListener(\"WeixinJSBridgeReady\", function () &#123; music.play();&#125;, false);//小结//1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常//2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间&lt;/script&gt; 重力感应事件123456789101112131415161718192021222324// 运用HTML5的deviceMotion，调用重力感应事件if(window.DeviceMotionEvent)&#123; document.addEventListener('devicemotion', deviceMotionHandler, false)&#125; var speed = 30;var x = y = z = lastX = lastY = lastZ = 0;function deviceMotionHandler(eventData)&#123; var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed )&#123; //这里是摇动后要执行的方法 yaoAfter(); &#125; lastX = x; lastY = y; lastZ = z;&#125;function yaoAfter()&#123; //do something&#125; 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整123456789101112131415161718192021//以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理if (typeof(WeixinJSBridge) == \"undefined\") &#123; document.addEventListener(\"WeixinJSBridgeReady\", function (e) &#123; setTimeout(function()&#123; WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize':0&#125;, function(res)&#123; alert(JSON.stringify(res)); &#125;) &#125;, 0) &#125;);&#125;else&#123; setTimeout(function()&#123; WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize':0&#125;, function(res)&#123; alert(JSON.stringify(res)); &#125;) &#125;, 0) &#125;//IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小body &#123; -webkit-text-size-adjust:100%!important; &#125;//最好的解决方案：最好使用rem或百分比布局 定位的坑123456789101112131415161718192021222324252627282930313233//fixed定位//1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位//2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位//3.ios4下不支持position:fixed//解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如：&lt;div id=\"wrapper\"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ..... &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"iscroll.js\"&gt;&lt;/script&gt;&lt;script&gt; var myscroll; function loaded()&#123; myscroll=new iScroll(\"wrapper\"); &#125; window.addEventListener(\"DOMContentLoaded\",loaded,false);&lt;/script&gt;&lt;script&gt;//position定位//Android下弹出软键盘弹出时，影响absolute元素定位//解决方案:var ua = navigator.userAgent.indexOf('Android');if(ua&gt;-1)&#123; $('.ipt').on('focus', function()&#123; $('.css').css(&#123;'visibility':'hidden'&#125;) &#125;).on('blur', function()&#123; $('.css').css(&#123;'visibility':'visible'&#125;) &#125;)&#125;&lt;/script&gt; 播放视频不全屏lang:12345678&lt;!--1.ios7+支持自动播放2.支持Airplay的设备（如：音箱、Apple TV)播放x-webkit-airplay=\"true\" 3.播放视频不全屏webkit-playsinline=\"true\" --&gt;&lt;video x-webkit-airplay=\"true\" webkit-playsinline=\"true\" preload=\"auto\" autoplay src=\"http://\"&gt;&lt;/video&gt; JS判断设备12345678910111213function deviceType()&#123; var ua = navigator.userAgent; var agent = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; for(var i=0; i&lt;len,len = agent.length; i++)&#123; if(ua.indexOf(agent[i])&gt;0)&#123; break; &#125; &#125;&#125;deviceType();window.addEventListener('resize', function()&#123; deviceType();&#125;) JS判断微信浏览器12345678function isWeixin()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)=='micromessenger')&#123; return true; &#125;else&#123; return false; &#125;&#125; android 4.x bug1234//1.三星 Galaxy S4中自带浏览器不支持border-radius缩写//2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分//3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色//4.android无法同时播放多音频audio 消除transition闪屏12345.css &#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000;&#125; 开启硬件加速1234567//目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。.css &#123; -webkit-transform: translate3d(0,0,0); -moz-transform: translate3d(0,0,0); -ms-transform: translate3d(0,0,0); transform: translate3d(0,0,0);&#125; 渲染优化123456789//1.禁止使用iframe（阻塞父文档onload事件）//2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）//使用CSS3代码代替JS动画；//开启GPU加速；//使用base64位编码图片(不小图而言，大图不建议使用) // 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于： //1.减少HTTP请求； //2.避免文件跨域； //3.修改及时生效； 腾讯方案123456789101112131415161718192021222324252627282930313233var autoScale = function()&#123; var ratio = 320/504, //这是设计稿的宽高比（504是Iphone的高度去掉标题栏高度） winW = document.getElement.clientWidth, winH = document.getElement.clientHeight, ratio2 = winW/winH, scale; if(ratio&lt;ratio2)&#123; scale = (winH/504).toString().substring(0, 6); &#125;else&#123; scale = (winW/320).toString().substring(0, 6); &#125; var cssText = '-webkit-transform: scale('+scale+');-webkit-transform-origin: top; opacity:1;' $('.wrap').attr('style', cssText);&#125;setTimeout(function()&#123; if(document.documentElement.clientWidth/document.documentElement.clientHeight !== 320/504)&#123; autoScale(); &#125;else&#123; $('.page').css(&#123;'opacity': 1&#125;); &#125;&#125;, 300) //添加一定时长以确保宽高获取正确window.addEventListener('onorientationchange' in window?'orientationchange':'resize', autoScale, false)&#123; detectOrientatioin();&#125; //切换横竖屏function detectOrientatioin()&#123; if(window.orientation==180 || window.orientation==0)&#123; //竖屏 &#125; if(window.orientation==90 || window.orientation==-90)&#123; //横屏 &#125;&#125; 张叶兮的群12345678910//有问必答社区，懂得人来，自己的群以前闹着玩弄得&lt;script&gt;(function(name)&#123;let uname = name || \"\";let come = unescape(\"%u963F%u91CC%u4EBA%u521B%u5EFA%u7684%u524D%u7AEF%u5171%u4EAB%u5C0F%u7FA4%2Cwill%20join%20us%3F\");let mima = \"62017~72017~32017~12017~42017~42017~62017~52017~5\";let js = mima.split(\"2017~\").reverse().join(\"\");//will you? return come+\" \"+uname+\" come on~ \"+js;&#125;)(\"friends\")&lt;/script&gt; 根据多方资料整理 欢迎交流转载请注明出处","categories":[{"name":"h5","slug":"h5","permalink":"https://joacycode.github.io/categories/h5/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"h5","slug":"h5","permalink":"https://joacycode.github.io/tags/h5/"},{"name":"api","slug":"api","permalink":"https://joacycode.github.io/tags/api/"}],"keywords":[{"name":"h5","slug":"h5","permalink":"https://joacycode.github.io/categories/h5/"}]},{"title":"浅析linux chmod命令","slug":"20161213linux","date":"2016-12-13T00:00:00.000Z","updated":"2021-09-26T02:00:01.896Z","comments":true,"path":"posts/82735d62/","link":"","permalink":"https://joacycode.github.io/posts/82735d62/","excerpt":"最近遇到一同事问我怎么快速的给文件夹加密，我寻思着这货又收集什么见不得人的机密了，给文件夹或者文件加密的方式有很多，要钱的不要钱的就说你想要什么样的吧。得，整了半天给我来句只要别人没权限打开就成，那这不好办么，直接设个权限不就完事了么，暂时糊弄糊弄一些生瓜蛋子做到打不开就死心还是可以的。最近正好遇到一些涉及到权限问题的事，就在这捋一捋，认识认识新词。linux有个命令叫chmod，就是更改权限的作用。1chmod [-cfvR] [--help] [--version] mode file...","text":"最近遇到一同事问我怎么快速的给文件夹加密，我寻思着这货又收集什么见不得人的机密了，给文件夹或者文件加密的方式有很多，要钱的不要钱的就说你想要什么样的吧。得，整了半天给我来句只要别人没权限打开就成，那这不好办么，直接设个权限不就完事了么，暂时糊弄糊弄一些生瓜蛋子做到打不开就死心还是可以的。最近正好遇到一些涉及到权限问题的事，就在这捋一捋，认识认识新词。linux有个命令叫chmod，就是更改权限的作用。1chmod [-cfvR] [--help] [--version] mode file... 说明 :Linux/Unix 的档案存取权限用户群体分为三级 : 拥有者、群组、其他。利用 chmod 可以控制档案如何被他人所存取。mode : 权限设定字串，让你看写啊删啊执行啊都在这设置1[ugoa...][[+-=][rwxX]...][,...] 细细表来上面都是些什么东东： u:表示该档案的拥有者g: 表示与该档案的拥有者属于同一个群体(group)者o :表示其他以外的人a: 表示这三者皆是+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。-c : 若该档案权限确实已经更改，才显示其更改动作-f : 若该档案权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 范例 :将老同事的 xx.avi 设为所有人皆可读取（不厚道的笑了）1chmod ugo+r xx.avi 另一种写法 1chmod a+r xx.avi 现在将老同事的 xx.avi 与 some.jpg 权限设为他与其所属同一个群体者可写入，比如做一些文本编辑图片处理啊什么的，但其他以外的人则不可写入，但是他们可以读取的到。 1chmod ug+w,o-w file1.txt file2.txt 将 ex1.py 设定为只有该档案拥有者可以执行 1chmod u+x ex1.py 将目前目录下的所有档案与子目录皆设为任何人可读取 1chmod -R a+r * 此外chmod也可以用数字来表示权限如 chmod 777 file ，这是更简便更有逼格的写法了，懂得人自然会心一笑，不懂得人一脸懵X。语法为：chmod ugo xx.file其中u,g,o各为一个数字，分别表示User、Group、及Other的权限。 12 u - g - or4w2x1-r4w2x1-r4w2x1 心法都在这了，领走闭关练练 1234r=4 (二进制 100 )，w=2 (二进制 010 )，x=1 (二进制 001 )若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5 给个栗子： 123chmod a=rwx file等同于chmod 777 file 123chmod ug=rwx,o=x file等同于chmod 771 file 若用chown 4755 filename可使此程式具有root的权限指令名称 : chown使用权限 : root 使用方式 1chown [-cfhvR] [--help] [--version] user[:group] file... 说明 : Linux/Unix 是多人多工作业系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限。 user : 新的档案拥有者的使用者 IDgroup :新的档案拥有者的使用者群体(group)-c :若该档案拥有者确实已经更改，才显示其更改动作-f :若该档案拥有者无法被更改也不要显示错误讯息-h :只对于连结(link)进行变更，而非该 link 真正指向的档案-v :显示拥有者变更的详细资料-R :对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 举个栗子 :将档案 file1.txt 的拥有者设为 users 群体的使用者 tommy : 1chown tommy:users file1.txt 将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 dannie(ahaahaha) : 1234567891011121314chmod -R dannie:users *-rw------- (600) -- 只有属主有读写权限。-rw -r- -r-- (644) -- 只有属主有读写权限；而属组用户和其他用户只有读权限。-rwx--- --- (700) -- 只有属主有读、写、执行权限。-rwx r-x r-x (755) -- 属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。-rwx --x --x (711) -- 属主有读、写、执行权限；而属组用户和其他用户只有执行权限。-rw- rw- rw- (666) -- 所有用户都有文件读、写权限。这种做法不可取。-rwx rwx rwx (777) -- 所有用户都有读、写、执行权限。更不可取的做法 以下是对目录的两个普通设定: 12345d rwx --- --- (700) 只有属主可在目录中读、写。d rwx r-x r-x (755) 所有用户可读该目录，但只有属主才能改变目录中的内容suid的代表数字是4，比如4755的结果是-rws r-x r-xsgid的代表数字是2，比如6755的结果是-rws r-s r-xsticky位代表数字是1，比如7755的结果是-rws r-s r-t 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"chmod","slug":"chmod","permalink":"https://joacycode.github.io/tags/chmod/"},{"name":"linux","slug":"linux","permalink":"https://joacycode.github.io/tags/linux/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"js基础核心梳理之Video","slug":"20161120video","date":"2016-11-20T00:00:00.000Z","updated":"2021-09-26T02:00:01.897Z","comments":true,"path":"posts/ad164cf7/","link":"","permalink":"https://joacycode.github.io/posts/ad164cf7/","excerpt":"最近在做H5的播放器video，随带着查查资料研究下flash工具和H5技术标准现在的情况。相比较于flash,H5在越来越明朗的移动市场上更具有光明的前景，youtube、apple的无flash产品线似乎已经引领了某种趋势，即使在pc上随着现代浏览器厂商的对H5的支持越来越全面，H5也能占据一席之地。原生的api video audio canvas等普及，H5这个新技术标准会把web动画视频游戏领域带入另一个高潮。","text":"最近在做H5的播放器video，随带着查查资料研究下flash工具和H5技术标准现在的情况。相比较于flash,H5在越来越明朗的移动市场上更具有光明的前景，youtube、apple的无flash产品线似乎已经引领了某种趋势，即使在pc上随着现代浏览器厂商的对H5的支持越来越全面，H5也能占据一席之地。原生的api video audio canvas等普及，H5这个新技术标准会把web动画视频游戏领域带入另一个高潮。Adobe太封闭了，产品100%私有。Flash影片大多遵循H.264格式，这种格式苹果是支持的；至于没有Flash游戏，不足以错过APP Store里精彩的游戏人生。一旦支持Flash，苹果移动设备的稳定性、安全性会大大降低。Flash非常耗电。想让Flash适应触控设计，你得重写代码，还不如用更先进的HTML5。最后也是最重要的，完全依赖第三方软件开发，会延误我们所有人使用其他产品的新功能。 乔布斯 《Flash之我见》 上面整理了乔帮主怼flash的文章的截取，这里就知道为什么flash会衰落，HTML5会兴起的原因了，后来谷歌帝国、脸书帝国、油管帝国都在慢慢的嫌弃flash的道路上越走越远，移动端的flash的停更说明连Adobe自己也看不下去这个产品了，这个现象就像多米诺骨牌，让我们这些当年的吃瓜群众纷纷侧目，怀疑某个兴盛的时代是不是说变就变了。我感觉到国际巨头互联网企业想推一个产品而且是正确的时代产品，这个产品就是这个领域的未来。那到底啥是flash,Flash是一种交互式矢量图与Web动画标准，因为体积小、易于传输、不失真等优点，契合2000年前后小带宽的互联网环境，迅速在全球崛起，简直就是时代骄子，横跨影视、游戏、广告领域，说是霸主简直都是在污蔑他的影响力，市场占有率几乎100%，然而一个朝代故步自封，不思进取也会被新的王朝替代，所以flash最终被H5还是其他的产品挤下神坛都是迟早的事，就看谁能在flash的棺材班上钉上最后一颗钉子。那么废话结束了，唉，还是要学点东西才能赶上他们眼里的旧时代，这日子没法过了。先列个video的基础api梳理，毕竟是最近做的事，以后专门再开个canvas专题、websocket专题把踩坑记录心得拿上来记一记。 Video 对象属性src 设置或返回视频的 src 属性的值。 height 设置或返回视频的 height 属性的值。 width 设置或返回视频的 width 属性的值。 controls 设置或返回视频是否应该显示控件（比如播放/暂停等）。 loop 设置或返回视频是否应在结束时再次播放。 autoplay 设置或返回是否在就绪（加载完成）后随即播放视频。 poster 设置或返回视频的 poster 属性的值,不播放视频时显示的图片。 muted 设置或返回是否关闭声音。 defaultMuted 设置或返回视频默认是否静音。 ended 返回视频的播放是否已结束。 volume 设置或返回视频的音量。 defaultPlaybackRate 设置或返回视频的默认播放速度。 playbackRate 设置或返回视频播放的速度。 preload 设置或返回视频的 preload 属性的值，提前加载视频 none auto metadata。 duration 返回视频的长度（以秒计）。 currentTime 设置或返回视频中的当前播放位置（以秒计）。 currentSrc 返回当前视频的 URL。 readyState 返回视频当前的就绪状态。 networkState 返回视频的当前网络状态。 paused 设置或返回视频是否暂停。 error 返回表示视频错误状态的 MediaError 对象 只读。 seeking 返回用户当前是否正在视频中进行查找。 played 返回表示视频已播放部分的 TimeRanges 对象。 audioTracks 返回表示可用音频轨道的 AudioTrackList 对象。 buffered 返回表示视频已缓冲部分的 TimeRanges 对象。 controller 返回表示视频当前媒体控制器的 MediaController 对象。 crossOrigin 设置或返回视频的 CORS 设置。 mediaGroup 设置或返回视频所属媒介组合的名称。 seekable 返回表示视频可寻址部分的 TimeRanges 对象。 startDate 返回表示当前时间偏移的 Date 对象。 textTracks 返回表示可用文本轨道的 TextTrackList 对象。 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象。 Video 对象方法方法 描述 play() 开始播放视频。 pause() 暂停当前播放的视频。 addTextTrack() 向视频添加新的文本轨道。 canPlayType() 检查浏览器是否能够播放指定的视频类型。返回空串或 “maybe” “probably” load() 重新加载视频元素。 Video 事件play即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay属性 abort浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的 pause播放暂停，当执行了pause方式时触发 waiting播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够得到下一帧 progress浏览器正在获取媒体数据 loadeddata事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频（audio/video）的下一帧时触发。 error获取媒体数据过程中出错 loadedmetadata浏览器获取完毕媒体的时间长和字节数 timeupdate由于播放位置被改变，可能是播放过程中的自然改变，也可能是被人为的改变，或由于播放不能连续而发生的跳变 ended播放结束后停止播放 canplay浏览器能够播放媒体，但估计以当前的播放速率不能直接播放完毕，播放期间需要缓冲 canplaythrough浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲 volumechangevolume属性（音量）被改变或muted属性（静音状态）被改变 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"video","slug":"video","permalink":"https://joacycode.github.io/tags/video/"},{"name":"全屏","slug":"全屏","permalink":"https://joacycode.github.io/tags/全屏/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"Html Css编码规范心得","slug":"20161108guifan","date":"2016-11-08T00:00:00.000Z","updated":"2021-09-26T02:00:01.895Z","comments":true,"path":"posts/e978f84e/","link":"","permalink":"https://joacycode.github.io/posts/e978f84e/","excerpt":"Css编码规范 Html编码规范 Css类名约定…","text":"Css编码规范 Html编码规范 Css类名约定… Css编码规范总结笔记 1.左花括号前添加空格，右花括号单独成行，声明 : 后插入空格2.为选择器分组时，将单独的选择器单独放在一行3.小写字母加连字符（不是下划线，也不是驼峰命名法）4.需在js中使用的类名以 J_ 开头，接“大驼峰”命名，这类的class不能出现在CSS文件中5.排列顺序定位（position、left、right、top、bottom、z-index）盒子模型（display、float、width、height、margin、padding、border、border-radius）排印（font、color、background、line-height、text-align 123456789101112131415161718192021222324252627&lt;input type=\"text\" class=\"J_UserType_Email\"&gt;&lt;style&gt;.selector,.mod-example &#123; /* 定位 */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* 盒模型 */ display: block; float: right; width: 100px; height: 100px; margin: 15px auto; padding: 10px 15px; border: 1px solid #ccc; /* 排印 */ font: normal 13px \"Helvetica Neue\", sans-serif; line-height: 1.5; color: #333; background-color: #f5f5f5; text-align: center;&#125;&lt;/style&gt; Html编码规范 1.使用简单的doctype2.统一使用utf-83.html元素上指定lang属性4.指定什么版本的IE渲染页面5.引入css、js不需要指明type6.缩进使用两个空格7.标签属性名统一小写8.属性引号用双引号9.Boolean 属性指不需要声明取值的属性10.自定义属性必须以 data- 为前缀11.HTML属性顺序按class、id、name、data-*…顺序出现12.不要在自动闭合标签的结尾处使用斜线13.id命名，当作为 JS 钩子使用 时，以 J_ 为前缀，后面接大驼峰命名14.html代码中不能出现任何关于业务相关敏感信息的注释 建议结构123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta lang=\"zh\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"keyword\" content=\"\"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"example.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" disabled&gt; &lt;a class=\"...\" id=\"...\" data-modal=\"toggle\" href=\"#\"&gt; &lt;script src=\"example.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Css类名约定[建议]个人总结，利用约定规则进行css命名空间冲突解决 一级类名全局1#[PROJECT]-g-[module] 页面1#[PROJECT]-[page]-[module] 页面组件1.[PRJECT]-[page]-[module] 其中PRJECT为项目标志，g为全局标志，page为页面标志，module为特定模块 项目为YT，header模块公共 1.YT-g-header&#123;&#125; 项目为YT，header不公共，且header里有多种情况，这时候就需要分页面去做1.YT-index-header.YT-index-mobile&#123;&#125; 二级类名1[module]-[detail] 其中module为模块标志，detail为细节模块标志，123.header[Top,Bottom,left,right,Nav...] .conter[Top,Bottom,Left,Right,Mid...] .footer[Top,Bottom,left,right...] 更多情况1.[module]-[detail].[detailA,detailB,detailC...] 三级四级类名[detail] 只要同级别之间不重复命名即可 例子1234567891011121314151617&lt;div class=\"YT-g-header YT-index-header YT-index-mobile\"&gt;&lt;/div&gt;&lt;div class=\"YT-g-header YT-index-trade\"&gt;&lt;/div&gt;&lt;div class=\"YT-index-conter YT-index-mobile\"&gt; &lt;div class=\"conter-top dog none\"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"conter-top cat\"&gt; &lt;a href =\"#\" class=\"spat\"&gt;&lt;/a&gt; &lt;b class=\"name\"&gt;&lt;/b&gt; &lt;p class=\"desp\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"conter-mid\"&gt;&lt;/div&gt; &lt;div class=\"conter-bottom\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"YT-index-conter YT-index-trade\"&gt;&lt;/div&gt;&lt;div class=\"YT-g-footer YT-index-mobile\"&gt;&lt;/div&gt;&lt;div class=\"YT-g-footer YT-index-trade\"&gt;&lt;/div&gt;pub-g.css一旦定下来，非common的元素类不要写进去，有特殊写在当前page的css里 通过增加.[PROJECT]-[PAGE]-[MOD]即可覆盖改写或者增加当前样式或者子元素样式。 欢迎交流转载请注明出处","categories":[{"name":"other","slug":"other","permalink":"https://joacycode.github.io/categories/other/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://joacycode.github.io/tags/规范/"},{"name":"html","slug":"html","permalink":"https://joacycode.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://joacycode.github.io/tags/css/"}],"keywords":[{"name":"other","slug":"other","permalink":"https://joacycode.github.io/categories/other/"}]},{"title":"js基础核心梳理之常用事件","slug":"20161022event","date":"2016-10-22T00:00:00.000Z","updated":"2021-09-26T02:00:01.896Z","comments":true,"path":"posts/64c6bd1d/","link":"","permalink":"https://joacycode.github.io/posts/64c6bd1d/","excerpt":"这里整理了一般事件、页面相关事件、表单相关事件、滚动字幕事件、滚动字幕事件、编辑事件、数据绑定的相关api,仅供参考查阅。","text":"这里整理了一般事件、页面相关事件、表单相关事件、滚动字幕事件、滚动字幕事件、编辑事件、数据绑定的相关api,仅供参考查阅。一般事件12345678910onClick 鼠标点击事件，多用在某个对象控制的范围内的鼠标点击onDblClick 鼠标双击事件 onMouseDown 鼠标上的按钮被按下了 onMouseUp 鼠标按下后，松开时激发的事件 onMouseOver 当鼠标移动到某对象范围的上方时触发的事件 onMouseMove 鼠标移动时触发的事件 onMouseOut 当鼠标离开某对象范围时触发的事件 onKeyPress 当键盘上的某个键被按下并且释放时触发的事件.[注意:页面内必须有被聚焦的对象] onKeyDown 当键盘上某个按键被按下时触发的事件[注意:页面内必须有被聚焦的对象] onKeyUp 当键盘上某个按键被按放开时触发的事件[注意:页面内必须有被聚焦的对象] 页面相关事件123456789onAbort 图片在下载时被用户中断 onBeforeUnload 当前页面的内容将要被改变时触发的事件 onError 捕抓当前页面因为某种原因而出现的错误，如脚本错误与外部数据引用的错误 onLoad 页面内空完成传送到浏览器时触发的事件，包括外部文件引入完成 onMove 浏览器的窗口被移动时触发的事件 onResize 当浏览器的窗口大小被改变时触发的事件 onScroll 浏览器的滚动条位置发生变化时触发的事件 onStop 浏览器的停止按钮被按下时触发的事件或者正在下载的文件被中断 onUnload 当前页面将被改变时触发的事件 表单相关事件12345onBlur 当前元素失去焦点时触发的事件 [鼠标与键盘的触发均可] onChange 当前元素失去焦点并且元素的内容发生改变而触发的事件 [鼠标与键盘的触发均可] onFocus 当某个元素获得焦点时触发的事件 onReset 当表单中RESET的属性被激发时触发的事件 onSubmit 一个表单被递交时触发的事件 滚动字幕事件123onBounce 在Marquee内的内容移动至Marquee显示范围之外时触发的事件 onFinish 当Marquee元素完成需要显示的内容后触发的事件 onStart 当Marquee元素开始显示内容时触发的事件 编辑事件123456789101112131415161718192021onBeforeCopy 当页面当前的被选择内容将要复制到浏览者系统的剪贴板前触发的事件 onBeforeCut 当页面中的一部分或者全部的内容将被移离当前页面[剪贴]并移动到浏览者的系统剪贴板时触发的事件 onBeforeEditFocus 当前元素将要进入编辑状态 onBeforePaste 内容将要从浏览者的系统剪贴板传送[粘贴]到页面中时触发的事件 onBeforeUpdate 当浏览者粘贴系统剪贴板中的内容时通知目标对象 onContextMenu 当浏览者按下鼠标右键出现菜单时或者通过键盘的按键触发页面菜单时触发的事件 [试试在页面中的&lt;body&gt;中加入onContentMenu=\"return false\"就可禁止使用鼠标右键了] onCopy 当页面当前的被选择内容被复制后触发的事件 onCut 当页面当前的被选择内容被剪切时触发的事件 onDrag 当某个对象被拖动时触发的事件 [活动事件] onDragDrop 一个外部对象被鼠标拖进当前窗口或者帧 onDragEnd 当鼠标拖动结束时触发的事件，即鼠标的按钮被释放了 onDragEnter 当对象被鼠标拖动的对象进入其容器范围内时触发的事件 onDragLeave 当对象被鼠标拖动的对象离开其容器范围内时触发的事件 onDragOver 当某被拖动的对象在另一对象容器范围内拖动时触发的事件 onDragStart 当某对象将被拖动时触发的事件 onDrop 在一个拖动过程中，释放鼠标键时触发的事件 onLoseCapture 当元素失去鼠标移动所形成的选择焦点时触发的事件 onPaste 当内容被粘贴时触发的事件 onSelect 当文本内容被选择时的事件 onSelectStart 当文本内容选择将开始发生时触发的事件 数据绑定12345678910111213141516onAfterUpdate 当数据完成由数据源到对象的传送时触发的事件 onCellChange 当数据来源发生变化时 onDataAvailable 当数据接收完成时触发事件 onDatasetChanged 数据在数据源发生变化时触发的事件 onDatasetComplete 当来子数据源的全部有效数据读取完毕时触发的事件 onErrorUpdate 当使用onBeforeUpdate事件触发取消了数据传送时，代替onAfterUpdate事件 onRowEnter 当前数据源的数据发生变化并且有新的有效数据时触发的事件 onRowExit 当前数据源的数据将要发生变化时触发的事件 onRowsDelete 当前数据记录将被删除时触发的事件 onRowsInserted 当前数据源将要插入新数据记录时触发的事件 onAfterPrint 当文档被打印后触发的事件 onBeforePrint 当文档即将打印时触发的事件 onFilterChange 当某个对象的滤镜效果发生变化时触发的事件 onHelp 当浏览者按下F1或者浏览器的帮助选择时触发的事件 onPropertyChange 当对象的属性之一发生变化时触发的事件 onReadyStateChange 当对象的初始化属性值发生变化时触发的事件 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"event","slug":"event","permalink":"https://joacycode.github.io/tags/event/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"shell快捷启动sublime vsCode方法","slug":"20160929sublime","date":"2016-09-29T00:00:00.000Z","updated":"2021-09-26T02:00:01.895Z","comments":true,"path":"posts/66c9f5d6/","link":"","permalink":"https://joacycode.github.io/posts/66c9f5d6/","excerpt":"最近在使用命令行去打开需要编辑的文本的时候，一直想使用自己习惯的编辑器去打开（sublimeText、vsCode都是友好型的优秀的编辑器），默认的命令行vim编辑器用的不是很习惯，于是想到使用alias方法可以做这些事，只需要简单几步，就可以实现,以下针对sublime为例。环境平台：mac","text":"最近在使用命令行去打开需要编辑的文本的时候，一直想使用自己习惯的编辑器去打开（sublimeText、vsCode都是友好型的优秀的编辑器），默认的命令行vim编辑器用的不是很习惯，于是想到使用alias方法可以做这些事，只需要简单几步，就可以实现,以下针对sublime为例。环境平台：mac Step1. 安装编辑器可直接到以下网址下载dmg安装文件：Sublime Text 3地址戳这里vsCode地址戳这里 Step2. 添加命令行别名打开用户配置文件1vim ~/.bash_profile 添加如下alias1alias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\" ＃如果不添加别名，也可以选择将路径添加到环境变量下。＃这里的路径根据实际情况可能会有所不同。wq保存后回到命令行执行以下命令使其生效：1source ~/.bash_profile Step3. 命令行使用这里我们假设在命令行用SublimeText打开.bash_profile，则执行如下：1subl ~/.bash_profile 附-&gt;fish shell快捷启动sublimefish shell是一款极其易用上手的shell,具体安装和使用另开一篇做详细介绍。在fish shell里做alias方式如下： 1.打开fish配置目录1open ~/.config/fish 2.创建config.fish文件1touch config.fish 3.在config.fish里键入123function subl '/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' $argvend 注：$argv为参数 欢迎交流转载请注明出处","categories":[{"name":"tool","slug":"tool","permalink":"https://joacycode.github.io/categories/tool/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://joacycode.github.io/tags/sublime/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"https://joacycode.github.io/categories/tool/"}]},{"title":"js基础核心梳理之DOM操作","slug":"20160928dom","date":"2016-09-28T00:00:00.000Z","updated":"2021-09-26T02:00:01.897Z","comments":true,"path":"posts/1c6a5067/","link":"","permalink":"https://joacycode.github.io/posts/1c6a5067/","excerpt":"一、DOM创建DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数： Element，元素Attribute，属性Text，文本DOM节点创建最常用的便是document.createElement和document.createTextNode方法：12var node1 = document.createElement('div');var node2 = document.createTextNode('hello world!');","text":"一、DOM创建DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数： Element，元素Attribute，属性Text，文本DOM节点创建最常用的便是document.createElement和document.createTextNode方法：12var node1 = document.createElement('div');var node2 = document.createTextNode('hello world!'); 二、DOM查询返回当前文档中第一个类名为 “myclass” 的元素1var el = document.querySelector(\".myclass\"); 返回一个文档中所有的class为”note”或者 “alert”的div元素1var els = document.querySelectorAll(\"div.note, div.alert\"); 获取元素123var el = document.getElementById('xxx');var els = document.getElementsByClassName('highlight');var els = document.getElementsByTagName('td'); Element也提供了很多相对于元素的DOM导航方法：获取父元素、父节点123456789//没有定位父级时，默认是body;但在IE7以下，如果当前元素没有定位属性，返回body，如果有，返回HTML;//如果当前元素某个父级触发了haslayout，则返回触发了haslayout这个元素。var parent = ele.parentElement;var parent = ele.parentNode;//只读，没有兼容性问题var offsetParent=ele.offsetParent;//只读，找到最近的有定位的父节点。获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断var nodes = ele.children;//标准下、非标准下都只含元素类型，但对待非法嵌套的子节点，处理方式与childNodes一致。 var nodes = ele.childNodes;//非标准下：只包含元素类型，不会包含非法嵌套的子节点。//标准下：包含元素和文本类型，会包含非法嵌套的子节点。 获取元素属性列表1var attr = ele.attributes; 查询子元素12var els = ele.getElementsByTagName('td');var els = ele.getElementsByClassName('highlight'); 当前元素的第一个/最后一个子元素节点1234var el = ele.firstChild;//对待标准和非标准模式，如childNodsvar el = ele.lastChild;var el = ele.firstElementChild;//非标准不支持var el = ele.lastElementChild; 下一个/上一个兄弟元素节点1234var el = ele.nextSibling;var el = ele.previousSibling;var el = ele.nextElementSibling;var el = ele.previousElementSibling; 兼容的获取第一个子元素节点方法：1var first=ele.firstElementChild||ele.children[0]; 三、DOM更改添加、删除子元素12ele.appendChild(el);ele.removeChild(el); 替换子元素1ele.replaceChild(el1, el2); 插入子元素1parentElement.insertBefore(newElement, referenceElement); 克隆元素1ele.cloneNode(true) //该参数指示被复制的节点是否包括原节点的所有属性和子节点 四、属性操作获取一个{name, value}的数组1var attrs = el.attributes; 获取、设置属性12var c = el.getAttribute('class');el.setAttribute('class', 'highlight'); 判断、移除属性12el.hasAttribute('class');el.removeAttribute('class'); 是否有属性设置1el.hasAttributes(); 五、事件兼容封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*跨浏览器的事件处理程序 调用时候直接用domEvent.addEvent( , , );直接调用 使用时候，先用addEvent添加事件，然后在handleFun里面直接写其他函数方法，如getEvent； addEventListener和attachEvent---都是dom2级事件处理程序 */var domEvent = &#123; addEvent:function(element,event,handleFun)&#123; if(element.addEventListener)&#123; element.addEventListener(event,handleFun,false); &#125;// IE else if(element.attachEvent)&#123; element.attachEvent(\"on\"+event,handleFun); &#125; else&#123; element[\"on\"+event] = handleFun; &#125; &#125;, removeEvent:function(element,event,handleFun)&#123; if (element.removeEventListener) &#123; element.removeEventListener(event,handleFun,false); &#125;// IE else if (element.detachEvent) &#123; element.detachEvent(\"on\"+event,handleFun); &#125; else &#123; element[\"on\"+event] = null; &#125; &#125;, //阻止事件冒泡 stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true;#IE阻止事件冒泡，true代表阻止 &#125; &#125;, //阻止事件默认行为 preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false;//IE阻止事件冒泡，false代表阻止 &#125; &#125;, //获得事件元素 getElement:function(event)&#123; return event.target || event.srcElement; &#125;, //获得事件 getEvent:function(event)&#123; return event? event : window.event; &#125;, //获得事件类型 getType:function(event)&#123; return event.type; &#125; 欢迎交流转载请注明出处","categories":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"dom","slug":"dom","permalink":"https://joacycode.github.io/tags/dom/"}],"keywords":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/categories/js/"}]},{"title":"Markdown常用语法梳理","slug":"20160620markdown","date":"2016-06-20T00:00:00.000Z","updated":"2021-09-26T02:00:01.893Z","comments":true,"path":"posts/46199434/","link":"","permalink":"https://joacycode.github.io/posts/46199434/","excerpt":"Markdown的宗旨是易读容写，它和html标记语言有点类似，前者是一种书写格式，后者是一种发布格式。这里只记录常用博客语法，不断更新中。 换行在插入处先按入两个以上的空格然后回车 标题# H1## H2##### H6","text":"Markdown的宗旨是易读容写，它和html标记语言有点类似，前者是一种书写格式，后者是一种发布格式。这里只记录常用博客语法，不断更新中。 换行在插入处先按入两个以上的空格然后回车 标题# H1## H2##### H6 区块引用每行的最前面加上&gt; ，区块引用内部可以使用其他Markdown语法。 this is a Blockquotes 也可以只在每个段落的首部加上&gt;,使用&gt;时要断好行，如果不断行，下面的内容会全部使用引用方式。 this is a Blockquotes,this is a Blockquotesthis is a Blockquotes 列表无序列表使用星号、加号或是减号作为列表标记，注意符号与内容之间有个空格 * + - 无序列表展示 无序列表展示 无序列表展示 有序列表则使用数字接着一个英文句点x. 有序列表展示 有序列表展示 有序列表展示 代码区块Markdown 会用&lt;pre&gt; 和&lt;code&gt; 标签来把代码区块包起来。 123function Test()&#123; return;&#125; hexo的Next主题的用时的代码区块会更加鲜明友好,还可以通过主题配置的_config.yml中的highlight_theme进行配置相应的色调。123function Test()&#123; return;&#125; 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。***---___ 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 行内式: 只要在方块括号后面紧接着圆括号并插入网址链接即可[description](link)[优酷-这世界很酷](http://youku.com) 优酷-这世界很酷 参考式: 在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记,暂时不用。 强调和斜体使用星号（）和底线（_）作为标记强调字词的符号，被 或 包围的字词会被转成用 &lt;em&gt;标签包围，用两个* 或 包起来的话，则会被转成&lt;strong&gt; 代码如果要标记一小段行内代码，你可以用反引号把它包起来 图片惊叹号加上方块括号后面紧接着圆括号并插入网址链接![title](link) 代码利用反斜杠来插入一些在语法中有其它意义的符号Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 欢迎交流转载请注明出处","categories":[{"name":"tool","slug":"tool","permalink":"https://joacycode.github.io/categories/tool/"}],"tags":[{"name":"js","slug":"js","permalink":"https://joacycode.github.io/tags/js/"},{"name":"markdown","slug":"markdown","permalink":"https://joacycode.github.io/tags/markdown/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"https://joacycode.github.io/categories/tool/"}]}]}